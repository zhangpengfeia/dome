## 项目初始化

### 1. 创建项目

#### 1.1 新建空白目录

```bash
1.新建一个空白目录project
2.进入到project目录上，然后打开gitbash
```

#### 1.2 创建vue项目

windows系统下如果使用 gitbash 执行如下命令

```bash
winpty vue.cmd create heima-pc
```

windows系统下如果使用 cmd 执行如下命令

```bash
vue create heima-pc
```

mac系统下直接执行如下命令

```bash
sudo vue create heima-pc
```

回车执行之后显示如下图所示，选中第三项

![](assets/select.png)



#### 1.3 选择项说明

```bash
# 默认选中两项
? Check the features needed for your project:
 (*) Babel       // js降级 （需要）
 ( ) TypeScript  // js语言的超集
 ( ) Progressive Web App (PWA) Support  // 可以在本地安装的webapp 
 ( ) Router   // 路由插件 （需要）
 ( ) Vuex     // 数据状态管理插件 （不需要）
>( ) CSS Pre-processors   // css预处理器 less  scss  stylus
 (*) Linter / Formatter   // 语言格式化
 ( ) Unit Testing   // 测试
 ( ) E2E Testing    // 测试
 
# 手动增加两项
# 选中方式：方向键移动 空格键选中

? Please pick a preset: Manually select features
? Check the features needed for your project:
 (*) Babel
 ( ) TypeScript
 ( ) Progressive Web App (PWA) Support
>(*) Router
 ( ) Vuex
 (*) CSS Pre-processors
 (*) Linter / Formatter
 ( ) Unit Testing
 ( ) E2E Testing

# 说明：
# Babel: ES6降级编译工具
# Router: 项目使用路由并且为我们生成好默认的路由代码
# CSS pre-processors: 容许我们使用css预处理器 less
# Linter/Formatter: 代码格式校验
```

#### 1.4 精细化配置项说明

1. 是否使用history路由模式

```bash
? Use history mode for router? (Requires proper server setup for index fallback
in production) (Y/n)
#是否使用history路由模式  这里选择n不使用
```

2. 使用哪种css预处理器

```bash
? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported
by default): (Use arrow keys)
  Sass/SCSS (with dart-sass)
  Sass/SCSS (with node-sass)
>  Less
  Stylus
# 这里选择大家熟悉的less
```

3. 使用哪个代码校验工具

```bash
? Pick a linter / formatter config: (Use arrow keys)
  ESLint with error prevention only
  ESLint + Airbnb config
> ESLint + Standard config
  ESLint + Prettier
# 推荐使用 ESLint + Standard config
```

4. 何时触发代码校验

```bash
? Pick additional lint features:
 (*) Lint on save
>(*) Lint and fix on commit
```

5. 配置文件是单独生成还是放到package.json文件中

```bash
? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)
> In dedicated config files
  In package.json
# 选择单独生成配置文件
```

6. 是否把上面的选择记录保存下来

```bash
? Save this as a preset for future projects? (y/N)
# 不保存 输入N
```

#### 1.5 启动项目

```bash
cd hm-pc
npm run serve

App running at:
- Local:   http://localhost:8080/  （端口号可能会变不是永远都是8080）
- Network: http://192.168.0.102:8080/

# 浏览器中输入http://localhost:8080/ 出现初始页面则项目创建成功
```

### 2. 远程仓库关联

> 将本地项目推送到远程方便管理

#### 2.1 创建gitee账号 

#### 2.2 在gitee中创建同名空白项目

```bash
已有仓库推送模板
cd existing_git_repo
(这个名字是一个样例名字 需要根据你本地的决定，它的意思是进入到项目目录)
git remote add origin https://gitee.com/cp_fe/hm-pc.git
git push -u origin master
```

#### 2.3 完成首次推送

```bash
git log 检查是否已经有了一次本地提交

# 如果已经有过一次本地提交
  git remote add origin https://gitee.com/cp_fe/hm-pc.git
  git push -u origin master
```

#### 2.4 后续修改提交

```bash
# 提交到本地
git add .
git commit -m "有意义的提交说明"
# 提交到远程仓库
git push
```

#### 2.5 可能遇到的问题

```bash
# 解决方案一
首次提交git push的时候要求输入用户名密码一定要保证输入正确
直接输入即可
如果时间长忘记了，可以将本地凭据删掉，重新输入再生成一次
凭据的位置： window10 为例   搜索 -> 凭据 -> 点击凭据管理器 -> 找到gitee凭据删掉
```

## 代码和目录规范

### 1. 代码规范

#### 	1.1 eslint规范

##### 目的

> 规范化javascript代码的书写格式   比如加不加分号 为的是团队代码风格统一化

##### 规则

> eslint + standard
>
> eslint规则：https://eslint.bootcss.com/docs/rules/
>
> standard规范：https://standardjs.com/rules.html

##### 报错信息学习

- 不符合规范的代码


```js
import Vue from 'vue'
import App from './App.vue'
import router from './router'
// 故意增加一个分号
Vue.config.productionTip = false;

new Vue({
  router ,
  render: h => h(App)
}).$mount('#app')
```

- 错误提示

![](http://cp_fe.gitee.io/assets/vue/eslint.png)

##### 如何修正错误

1. 手动修正（推荐）

   ```bash
   1. 找到发生错误的文件
   2. 在错误的文件中定位发生具体错误的行数
   3. 根据图示中的3的地方的关键词 打开https://eslint.bootcss.com/docs/rules/ 搜索具体的错误类型
   4. 进行手动修改
   ```

2. vscode插件修正 

   ```bash
   1.安装vscode eslint插件
   2.重启vscode
   3.开启保存自动格式化为正确的格式
     打开setting.json添加如下代码
     "editor.codeActionsOnSave": {
         "source.fixAll": true
      }
   ```

3. 注意问题

   1. 卸载之前的代码格式化插件避免格式冲突

   2. 关闭Format On Save配置项 

      ![](assets/eslint-vscode.png)
   
   3. 项目目录要位于vscode的最外层
   
      ![](assets/eslint-vscode1.png)

4. 小技巧

​         1. shift + alt + f（不管规则对htmlcssjs都格式化）    

​         2. ctrl + s (根据规则格式化js)

#####  配置自己的eslint规则

`.eslintrc.js`

```js
module.exports = {
  root: true,
  env: {
    node: true
  },
  extends: [
    'plugin:vue/essential',
    '@vue/standard'
  ],
  parserOptions: {
    parser: 'babel-eslint'
  },
  /*
    1.找到eslintrc.js文件
    2.找到rules配置项
    3.将自己不需要的eslint规则关闭
  */
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'semi': 'off'
  }
}
```

##### 如何关闭eslint校验 (不推荐)

> 如果非常严重的影响了心情和学习效果可以选择先关闭

1. 关闭保存时校验

   1. 在项目根目录新建`vue.config.js`文件
   2. 添加如下代码

   ```js
   module.exports = {
       lintOnSave: false
   }
   ```

2. 关闭commit时的报错

   `package.json`  

   ```
   "gitHooks": {
      // 删除默认的配置
   }
   ```

3. 重启项目

##### 使用eslint的场景

1. 全新项目从零开始的项目**(重点)**
2. 尽量给自己的项目加上eslint让规范化的代码成为习惯

#### 	1.2 vue代码风格

> vue作为一个框架制定了很多自己的语法规则 也应该有一个规范

vue风格建议：https://cn.vuejs.org/v2/style-guide/

vue组件配置项的书写顺序建议：

```js
export default {
    name:'hello',
    props:{},
    data(){},
    computed:{},
    methods:{},
    watch:{},
    created(){},
    mounted(){}
}
```

### 2. 目录规范

1. 删除自带的多余组件和素材

2. 增加几个必要的目录

   `src/api`     网络请求接口目录

   `src/utils `   js工具模块目录

   `src/styles`   全局样式目录	

   `src/views`   路由级别组件目录

3. 最终目录结构

   ```js
// 模块的拆分
// 1.方便维护 多方的配合的时候项目的结构不会乱
// 2.开发阶段 会给开发人员一个填鸭式的开发思维 提高开发效率
   ```

## 安装 Vue Devtools

https://github.com/vuejs/vue-devtools

vue项目才可以使用这个调试工具  

### 1. 已有安装包的安装步骤（重点）

```bash
1.打开chrome -> 更多工具 -> 扩展程序 -> 启动开发者模式
2.点击 '加载已解压的扩展程序' 选择 /packages/shell-chrome/
```

### 2. 如何使用

![整体架构设计](http://cp_fe.gitee.io/assets/vue/vue-devtools.png)

## Element组件库

### 1.  介绍

> 饿了么团队出品的专门为vue框架打造的pc组件库

官网：https://element.eleme.cn/#/zh-CN/component/quickstart

### 2.  基础使用

1. npm安装

   ```bash
   npm i element-ui -S
   ```

2. 完整引入

   ```js
   import ElementUI from 'element-ui'
   import 'element-ui/lib/theme-chalk/index.css'
   Vue.use(ElementUI)
   ```

3. 验证是否正常安装

   ```html
   <template>
     <div id="app">
       <h1>黑马头条pc后台</h1>
       <el-row>
         <el-button>默认按钮</el-button>
         <el-button type="primary">主要按钮</el-button>
         <el-button type="success">成功按钮</el-button>
         <el-button type="info">信息按钮</el-button>
         <el-button type="warning">警告按钮</el-button>
         <el-button type="danger">危险按钮</el-button>
       </el-row>
       <router-view />
     </div>
   </template>
   ```

   正常显示出按钮即表示安装成功

4. 其它组件的使用

   ```bash
   # 1.找到要使用的组件
   # 2.打开样例代码
   # 3.复制样例代码
   # 4.更改必要的代码添加我们自己的业务代码
   ```

## Axios请求库封装使用

> 官方文档：https://github.com/axios/axios

### 1. 安装axios插件

```bash
npm install axios -S
```

### 2. 封装简单的请求模块

`src/utils/request.js`

```js
// 导入axios模块
import axios from 'axios'
// 按照我们传入的参数创建一个实例出来
const instance = axios.create({
    // 当前项目的所有接口都是以这个地址开头的
    baseURL:'http://ttapi.research.itcast.cn/'
})
// 导出实例
export default instance
```

### 3. 基础测试使用

`src/app.vue`

```js
// 导入封装好的模块 名字可以更改
import request from '@/utils/request'
export default {
  mounted () {
    request({
      method: 'get',
      url: 'mp'
    })
  }
}
```

## 项目整体架构设计

### 1. 操作路径分析

1. 首先我们能看到的是登录页面
2. 用户输入正确的用户名和密码跳转到首页
3. 点击左侧菜单右侧开始显示不同的内容

> 俩个大路由 登录 和 首页  然后在首页中进行内部路由的切换

### 2. 整体架构图

![整体架构设计](http://cp_fe.gitee.io/assets/vue/架构3.png)

## 登录模块开发

### 1.  创建login组件

`src/views/Login/index.vue`

> 创建文件夹的原因：
>
> 1. 起到聚合的作用 如果有一天组件不用了，可以把组件和与之配套的静态资源一起删掉
> 2. 当前组件要使用静态资源的时候非常容器找到 而不需要一层一层的往外找

```html
<template>
  <div>我是登录页</div>
</template>

<script>
export default {
}
</script>

<style lang="less">
</style>

```

### 2. 组件和路由关联

```js
import Login from '@/views/Login'
const routes = [
  {
    path: '/login',
    name: 'Login',
    component: Login
  }
]
```

### 3. 验证是否关联成功

> 直接再浏览器中输入/login  正确显示 '我是登录页' 即为关联成功

### 4. 完成页面布局

核心Element组件：`el-form`

```html
<template>
  <div class="login-container">
  <div class="login-form-wrap">
    <div class="login-head">
      <div class="logo"></div>
    </div>
    <!--element-ui  表单组件 -->
    <el-form class="login-form">
      <el-form-item>
        <el-input
          placeholder="请输入手机号"
        ></el-input>
      </el-form-item>
      <el-form-item>
        <el-input
          placeholder="请输入验证码"
        ></el-input>
      </el-form-item>
      <el-form-item>
        <el-checkbox>我已阅读并同意用户协议和隐私条款</el-checkbox>
      </el-form-item>
      <el-form-item>
        <el-button
          class="login-btn"
          type="primary"
        >登录</el-button>
      </el-form-item>
    </el-form>
  </div>
  </div>
</template>

<script>
export default {
}
</script>

<style scoped lang="less">
.login-container {
  position: fixed;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction:column;
  justify-content: center;
  align-items: center;
  background: url("./img/login_bg.jpg") no-repeat;
  background-size: cover;
  .login-form-wrap {
    min-width: 300px;
    padding: 30px 50px 10px;
    background-color: #fff;
    .login-head {
      display: flex;
      justify-content: center;
      .logo {
        width: 200px;
        height: 57px;
        background: url("./img/logo_index.png") no-repeat;
        background-size: contain;
      }
    }
    .login-form {
      .login-btn {
        width: 100%;
      }
    }
  }
}
</style>

```

### 5. 完成核心业务逻辑

#### 逻辑梳理

```bash
# 1.判断手机和code是否为空
# 2.判断是否已同意协议    
# 3.1和2满足之后根据接口文档发送数据请求

# 测试账号：
# mobile:13911111111
# code:246810
```

#### 核心代码

```html
<script>
import request from '@/utils/request'
export default {
  data(){
    return {
      form:{
        mobile: '13911111111',
        code: '246810',
        checkFlag: false
      }
    }
  },
  methods:{
    doLogin(){
      // 数据校验
      if(this.form.checkFlag === false){
        alert('请先同意协议')
        return 
      }
      // 完成数据的提交
      // request = 添加了baseURL的axios
       request({
         url: '/mp/v1_0/authorizations',
         method: 'POST',
         data:{
           mobile: this.form.mobile,
           code: this.form.code
         }
       })
    }
  }
}
</script>
```

### 6. Element表单验证（重点）

#### 1. 背景知识

用户的输入内容往往不被信任，在我们向后端提交信息的时候，需要我们做表单验证，ElementUI提供了自己的一套验证规则，我们现在重点是学习ElementUI表单组件的验证规则

#### 常见的验证场景

- 内容是否为空
- 密码长度必须多少位
- 手机号的格式是否正确
- 邮箱的格式是否正确
- 其它

#### 2. 基础使用

> Form 组件提供了表单验证的功能，只需要通过 `rules` 属性传入约定的验证规则，并将 Form-Item 的 `prop` 属性设置为需校验的字段名即可

**以手机号输入校验作为实际操作案例**

```html
<!-- 
 1.给el-form添加一个:model属性 动态绑定data中放置了表单数据的属性
 2.给el-form添加一个:rules属性 动态绑定data中的放置规则的属性 
-->
<el-form class="login-form" ref="form" :model="user" :rules="rules">
</el-form>
<!-- 3.在组件的配置项的data中定义rules，并定义验证规则-->
<script>
export default {
  data () {
    return {
      form:{
        mobile: '13911111111',
        code: '246810',
        checkFlag: false
      },
      rules: {
        mobile: [
          { required: true, message: '请输入手机号', trigger: 'blur' }
        ]
      }
    }
  }
 }
</script>
<!-- 
 4.将el-form-item的prop字段设置为需要校验的字段名  
   prop属性的字段名需要和form中以及rules中的字段名保持一致
-->
<el-form class="login-form" ref="form" :model="user" :rules="rules">
  <el-form-item prop="mobile">
    <el-input
      v-model="user.mobile"
      placeholder="请输入手机号"
    ></el-input>
  </el-form-item>
</el-form>
```

#### 3. 添加多个验证规则

```html
<!-- 只需要在规则字段的数组中再添加一项规则 -->
<script>
export default {
  data () {
    return {
      form:{
        mobile: '13911111111',
        code: '246810',
        checkFlag: false
      },
      rules: {
        mobile: [
          { required: true, message: '请输入手机号', trigger: 'blur' },
          { max: 11, message: '长度不能超过11位', trigger: 'blur' }
        ]
      }
    }
  }
 }
</script>
```

#### 4. 添加自定义验证规则

> 有些时候我们需要更加灵活的规则控制 通过校验函数控制

**以验证码作为实际案例**

```js
export default {
  data () {
    // 1. 定义校验函数
    const validatePass = (rule, value, callback) => {
      // value表示表单元素中当前的值
      // callback表示进行校验之后要执行的回调函数
      // 最终校验成功之后的callback一定要执行到！！！！
      if (value === '') {
        callback(new Error('请输入验证码'))
      }
      callback()
    }
    return {
      form:{
        mobile: '13911111111',
        code: '246810',
        checkFlag: false
      },
      rules: {
        code: [
          // 2. 按照固定的格式添加到规则里
          { validator: validatePass, trigger: 'blur' }
        ]
      }
    }
  }
```

#### 5. 提交验证

> 点击提交按钮进行所有表单元素的验证

```js
// 之前的提交按钮绑定的函数应该变成校验函数 先进行校验 校验成功之后再正式提交
doValidate (formName) {
  this.$refs.form.validate((valid) => {
    // 当所有的校验规则都通过之后 valid的值才为true 否则为false
    if (valid) {
      this.doLogin()
    } else {
      return false
    }
  })
}
```

### 7. 封装登录请求模块

> 存在的问题
>
> 1. 现在发起登录的代码没有语义化
> 2. 没有一个集中管理网络请求的地方


` src/api/user.js`
```js
// 封装登录请求函数
// 这里的写法只是一种业内通用的写法而已
import request from '@/utils/request'
export const userLogin = (mobile, code) => {
  return request({
    url: '/mp/v1_0/authorizations',
    method: 'POST',
    data: {
      mobile,
      code
    }
  })
}
/*
函数说明：
1.login(mobile,code)调用实际上内部调用的是request函数并且把request函数调用的结果当成返回值返回

2.request函数的调用事实上是axios调用  而axios函数的调用返回值其实是个promise

3.login函数调用之后实际上拿到的是一个promise对象  既然是一个promise对象就可以调用then方法  login().then()
*/
```
`src/views/login/index.vue`

```js
// 使用
import { userLogin } from '@/api/user'
doLgoin () {
  userLogin(this.user.mobile, this.user.code).then(res => {
     console.log(res)
  })
  .catch(error => {
     console.log(error)
  })
}
```

**注**：不管是登陆模块还是其他模块 所有涉及到接口调用的地方都通过同样的封装方式进行统一封装 模块化调用

## Layout架构组件实现

### 基础组件搭建

#### 1 创建组件并绑定路由

`src/views/Layout/index.vue`

```html
<template>
  <div class="layout-container">layout</div>
</template>
```

`src/router/index.js`

```js

import Layout from '@/views/Layout'
const routes = [
  {
    path: '/',
    name: 'layout',
    component: Layout
  }
]
```

#### 2 完成整体布局

> 侧边栏和顶部是固定不变的，可变的只有主体区域作为路由视图出口
>
> 参考文档：[Container 布局容器](https://element.eleme.cn/#/zh-CN/component/container)

```html
<template>
  <el-container class="layout-container">
    <el-aside
      class="aside"
      width="240px">
      Aside 侧边栏
    </el-aside>
    <el-container>
      <el-header class="header">Header</el-header>
      <el-main class="main">
        <!--主体区域二级路由组件渲染的地方-->
        <router-view></router-view>
      </el-main>
    </el-container>
  </el-container>
</template>
<!-- 完整样式-->
<style lang="less" scoped>
.layout-container {
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
}
.aside {
  background-color: #002033;
  .el-menu {
    border-right: none;
  }
  .logo{
      width: 100%;
      height: 60px;
      background: #002244 url(./img/logo_admin.png) no-repeat center / 140px auto;
    }
    .minLogo{
      background-image: url(./img/logo_admin_01.png);
      background-size: 36px auto;
    }
}
.nav-menu {
  .iconfont {
    margin-right: 10px;
    padding-left: 5px;
  }
}
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid #ccc;
  .avatar-wrap {
    display: flex;
    align-items: center;
    .avatar {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      margin-right: 10px;
    }
  }
}
.main {
  background-color: #e9eef3;
}
</style>

```

#### 3 完成侧边栏布局

`el-menu`

```html
<el-aside
  class="aside"
  width="200px">
  <div class="logo"></div>
  <!-- 菜单区域 -->
  <el-menu
    default-active="/"
    class="nav-menu"
    background-color="#002033"
    text-color="#fff"
    active-text-color="#ffd04b"
  >
   <el-menu-item index="/">
    <i class="el-icon-s-home"></i>
    <span slot="title">首页</span>
  </el-menu-item>
  <el-menu-item index="/articles">
    <i class="el-icon-document"></i>
    <span slot="title">内容管理</span>
  </el-menu-item>
  <el-menu-item index="/image">
    <i class="el-icon-picture"></i>
    <span slot="title">素材管理</span>
  </el-menu-item>
  <el-menu-item index="/addArticle">
    <i class="el-icon-s-promotion"></i>
    <span slot="title">发布文章</span>
  </el-menu-item>
  <el-menu-item index="/comment">
    <i class="el-icon-chat-dot-round"></i>
    <span slot="title">评论管理</span>
  </el-menu-item>
  <el-menu-item index="/fans">
    <i class="el-icon-user"></i>
    <span slot="title">粉丝管理</span>
  </el-menu-item>
  <el-menu-item index="/settings">
    <i class="el-icon-setting"></i>
    <span slot="title">个人设置</span>
  </el-menu-item>
  </el-menu>
</el-aside>
```

#### 4 完成header区域布局

`el-dropdown`

```html
<el-header class="header">
    <div>
      <i class="el-icon-s-fold"></i>
      <span>黑马程序员</span>
    </div>
    <el-dropdown>
      <!-- 默认插槽：用来显示触发开关 -->
      <div class="avatar-wrap">
        <img class="avatar">
        <span>用户昵称</span>
        <i class="el-icon-arrow-down el-icon--right"></i>
      </div>
      <!--具名插槽：用来显示下拉内容 -->
      <el-dropdown-menu slot="dropdown">
        <el-dropdown-item>设置</el-dropdown-item>
        <el-dropdown-item>退出</el-dropdown-item>
      </el-dropdown-menu>
    </el-dropdown>
</el-header>

```

#### 5 实现侧边栏收起展开的效果

##### 背景知识

对el-menu组件来说，它有一个现成的属性[collapse](https://element.eleme.cn/#/zh-CN/component/menu#menu-attribute)来控制展开/收起状态，同时，它还有一个属性来控制这个过程中的动画`collapse-transition`,可以手动把它关闭

##### 需要完成的交互

1. 展开收起控制
2. 侧边栏宽度控制
3. logo大小控制
4. 小图标样式控制

##### 思路及代码

> 想到视图的变化就自然可以联想到通过数据来控制

1. data中新增数据项

   > isCollapse: false 来表示侧边栏的展示状态

2. 根据isCollapse值不同，来设置不同的效果

   (1) el-menu的样式  这一点由el-menu的collapse属性来自动控制

   ```html
   <el-menu
      :collapse="isCollapse"
      :collapse-transition="false"
   >
   ```

   (2) logo大小  如果是收起状态，则显示小logo，否则是普通logo大小 

   ```html
   <div class="logo" :class="{minLogo:isCollapse}"></div>
   ```

   (3) 侧边栏的宽度  如果收起状态，则是64px，否则是200px

   ```html
   <el-aside
      class="aside"
      :width="isCollapse?'64px':'200px'"
   >
   ```

   (4) 小图标的变化  收起状态和展开状态是两个不同的样式

   ```html
   <i :class="isCollapse ? 'el-icon-s-fold': 'el-icon-s-unfold'"
   @click="hSwitch"></i>
   ```

   

### 路由设计

#### 1. 路由表

| 序号 | 路径         | 组件        | 说明              | 路由级别       |
| ---- | ------------ | ----------- | ----------------- | -------------- |
| 1    | /login       | Login       | 用户登录          | 一级路由       |
| 2    | /            | Layout      | 首页 / 主页       | 一级路由  主页 |
| 3    | /home        | Home        | 默认显示页        | 二级路由       |
| 4    | /articles    | Article     | 内容管理-文章列表 | 二级路由       |
| 5    | /addArticle  | AddArticle  | 发布文章          | 二级路由       |
| 6    | /editArticle | EditArticle | 编辑文章          | 二级路由       |
| 7    | /image       | Image       | 素材管理          | 二级路由       |
| 8    | /comment     | Comment     | 评论管理          | 二级路由       |
| 9    | /fans        | Fans        | 粉丝管理          | 二级路由       |
| 10   | /setting     | Setting     | 账户设置          | 二级路由       |
| 11   | *            | NotFound    | 404页面           | 一级路由       |

#### 2. 菜单配置路由路径

> 开启 :router = "true"
>
> 是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转

```html
<el-aside
  class="aside"
  width="200px">
  <div class="logo"></div>
  <!-- 菜单区域 -->
  <el-menu
    default-active="/"
    class="nav-menu"
    background-color="#002033"
    text-color="#fff"
    active-text-color="#ffd04b"
    :router="true"
  >
  <el-menu-item index="/">
    <i class="el-icon-s-home"></i>
    <span slot="title">首页</span>
  </el-menu-item>
  <el-menu-item index="/articles">
    <i class="el-icon-document"></i>
    <span slot="title">内容管理</span>
  </el-menu-item>
  <el-menu-item index="/image">
    <i class="el-icon-picture"></i>
    <span slot="title">素材管理</span>
  </el-menu-item>
  <el-menu-item index="/addArticle">
    <i class="el-icon-s-promotion"></i>
    <span slot="title">发布文章</span>
  </el-menu-item>
  <el-menu-item index="/comment">
    <i class="el-icon-chat-dot-round"></i>
    <span slot="title">评论管理</span>
  </el-menu-item>
  <el-menu-item index="/fans">
    <i class="el-icon-user"></i>
    <span slot="title">粉丝管理</span>
  </el-menu-item>
  <el-menu-item index="/settings">
    <i class="el-icon-setting"></i>
    <span slot="title">个人设置</span>
  </el-menu-item>
  </el-menu>
</el-aside>
```

#### 3. 路由关联组件定义

`src/router/index.js`

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import Layout from '@/views/Layout'
// 默认会去寻找 index.vue
import Login from '@/views/Login/index.vue'
import Article from '@/views/Article'
import Image from '@/views/Image'
import ArticleAdd from '@/views/Article/articleAdd'
import ArticleEdit from '@/views/Article/articleEdit'
import Comment from '@/views/Comment'
import Fans from '@/views/Fans'
import Setting from '@/views/Setting'

Vue.use(VueRouter)

const routes = [
  {
    path:'/',
    name:'Layout',
    component: Layout,
    children:[
      { path:'articles', component:Article ,name:'Articles'},
      { path:'addArticle',component:ArticleAdd,name:'AddArticle'},
      { path:'editArticle',component:ArticleEdit,name:'EditArticle'},
      { path:'image', component:Image , name:'Image'},
      { path:'comment',component:Comment, name:'Comment'},
      { path:'fans',component:Fans, name:'Fans'},
      { path:'setting',component:Setting, name:'Setting'} 
    ]
  },
  {
    path: '/login',
    name: 'Login',
    component: Login
  }
]

const router = new VueRouter({
  routes
})

export default router

```

### 配置默认首页和404页

> 首页：网站介绍 没有实际的业务处理   
>
> 404页面：当输入的路径不在路由表里做友好提示

#### 1. 创建404组件和home组件

`src/views/NotFound/index.vue`

```html
<template>
  <div>
    404
  </div>
</template>

<script>
export default {
  name: 'NotFound'
}
</script>

```

`src/views/Home/index.vue`

```html
<template>
  <div>home</div>
</template>

<script>
export default {
    name:'Home'
}
</script>

<style lang="less" scoped>
</style>
```

#### 2.  配置路由

`src/router/index.js`

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import Layout from '@/views/Layout'
// 默认会去寻找 index.vue
import Login from '@/views/Login/index.vue'
import Article from '@/views/Article'
import Image from '@/views/Image'
import ArticleAdd from '@/views/Article/articleAdd'
import ArticleEdit from '@/views/Article/articleEdit'
import Comment from '@/views/Comment'
import Fans from '@/views/Fans'
import Setting from '@/views/Setting'
import Home from '@/views/Home'
import NotFound from '@/views/NotFound'

Vue.use(VueRouter)

const routes = [
  {
    path:'/',
    name:'Layout',
    component: Layout,
    redirect: { name: 'Home' },
    children:[
      { path:'home', component: Home, name: 'Home'},
      { path:'articles', component: Article , name:'Articles'},
      { path:'addArticle', component: ArticleAdd, name:'ArticleAdd'},
      { path:'editArticle', component: ArticleEdit, name:'ArticleEdit'},
      { path:'image', component:Image, name: 'Image'},
      { path:'comment', component:Comment, name: 'Comment'},
      { path:'fans', component:Fans, name: 'Fans'},
      { path:'setting', component:Setting, name: 'Setting'} 
    ]
  },
  {
    path: '/login',
    name: 'Login',
    component: Login
  },
  // 404组件一定要放到所有路由的最后做兜底处理
  {
    path:'*',
    component:NotFound
  }
]

const router = new VueRouter({
  routes
})

export default router
```

### 实现顶栏显示当前用户信息

#### 1. 逻辑分析

1. 在Layout组件中发起获取用户信息的请求
2. 拿到用户信息之后渲染到模板中



#### 2. 封装请求用户信息接口

> 由于所有的数据都是需要登陆之后才能看到的数据，所以我们需要按照接口要求添加Authorization

```js
export const userGetProfile = () => {
  return request({
    method: 'GET',
    url: '/mp/v1_0/user/profile',
    headers: {
      Authorization: 'Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2Mjc0NTM1MjYsInVzZXJfaWQiOjEsInJlZnJlc2giOmZhbHNlLCJ2ZXJpZmllZCI6dHJ1ZX0.3cXEX8UWzF_-4qaFXHFZwsSKJU04eKjorNGuxHVCkUA'
    }
  })
}
// 接口要求在请求头中添加token字段  我们先从login登录接口中拿到值写死测试用户信息接口
// 后面我们会做统一处理
```



#### 3. 调用接口将数据绑定到模板

```html
<template>
  <!-- 模板和数据绑定 -->
  <div class="avatar-wrap">
    <img class="avatar" :src="userInfo.photo" alt="">
    <span>{{userInfo.name}}</span>
    <i class="el-icon-arrow-down el-icon--right"></i>
  </div>
</template>

<script>
// 导入获取用户信息的方法
import { getUserInfo } from '@/api/user'
export default {
  data () {
    return {
      userInfo: {}
    }
  },
  methods: {
    // 创建设置用户信息的方法
    // 获取用户数据
    hGetUserInfo () {
      getUserInfo().then(res => {
        this.userInfo = res.data.data
      })
    }
  },
  mounted () {
    // 在组件挂载之后调用
    this.hGetUserInfo()
  }
}
```

## 接口鉴权

### 1. 什么是接口鉴权

> 前后端分离模式下 网站的数据都是通过接口获取而来的，有些接口只要提交数据格式正确就能访问，比如注册，登陆，更多的数据是私密性的，必须要有一个正确的**用户标识**才能访问，也就是告诉服务器你有访问当前数据的权力

### 2. token基础概念

> token说白了就是一串加密字符串  token可以作为用户标识用来代表当前用户是有权利访问数据的

### 3.  前后端流程图

![整体架构设计](http://cp_fe.gitee.io/assets/vue/架构图4.png)

```
1. 除了注册登陆接口外其他接口获取数据都需要在request headers 添加token才可以
2. 从后端获取古来的token我们采取localstrage本地存储方案进行存储
3. 获取token是通过登陆接口获取而来的
```

### 4.  本地持久化存储

> Localstorage

1. 浏览器内置对象
2. 可以持久化存储数据 如果不手动删除一直存在于本地
3. 只能存储字符串类型的数据
4. 最大存储量根据不同的浏览器不一致 （5M左右）

#### **基础用法**

```js
// 存值
localStorage.setItem('myCat', 'Tom')
// 取值
localStorage.getItem('myCat')
// 删除
localStorage.removeItem('myCat')
```

#### 封装本地存储

```js
// 封装对于用于数据的本地持久化存储
const KEY = 'heimapc'

// 1.存数据
export const setUserInfo = function (userInfo) {
  let userInfoStr
  try {
    userInfoStr = JSON.stringify(userInfo)
  } catch (error) {
    userInfoStr = ''
  }
  window.localStorage.setItem(KEY, userInfoStr)
}

// 2.取数据
export const getUserInfo = function () {
  let userInfo
  try {
    userInfo = JSON.parse(window.localStorage.getItem(KEY))
  } catch (error) {
    userInfo = {}
  }
  return userInfo
}
// 3.删除数据

export const delUserInfo = function () {
  window.localStorage.removeItem(KEY)
}

```

### 5.  登录接口调用时存储用户信息

```html
<!-- login.vue -->
<script>
  import { setUser } from '@/utils/store'
  export default {
      methods:{
          login () {
              userLogin(this.user.mobile, this.user.code).then(res => {
                // 设置用户信息
                setUser(res.data.data)
              }).catch(error => {
                console.log()
              })
          } 
      }
  }
</script>
```

### 6.  获取用户信息时获取本地token

```js
// api/user.js
// 封装登录请求函数
import request from '@/utils/request'
import { getUserInfo } from '@/utils/store'
export const userGetProfile = () => {
  // 获取存在本地的用户信息
  const user = getUserInfo()
  return request({
    method: 'GET',
    url: '/mp/v1_0/user/profile',
    headers: {
      Authorization: `Bearer ${user.token}`
    }
  })
}
```

### 7.  统一设置token-请求拦截器

##### 存在问题

> 如果每一个接口都需要在请求头上增加 Authorization，难道所有都单独写一次吗？

```js
export const userGetProfile = () => {
  const userInfo = getUserInfo()
  return ajax({
    method: 'GET',
    url: '/mp/v1_0/user/profile',
    // bad !!!
    headers: {
      Authorization: `Bearer ${userInfo.token}`
    }
  })
}
```

#####  概念理解

> 在axios基础配置request.js中添加一层统一的请求拦截，在所有的请求发起之前添加一些我们需要的信息，当前是往请求头header中添加Authorization

##### 具体实现

axios 拦截器官方示例：http://www.axios-js.com/docs/#Interceptors

`src/utils/request.js`

```js
// 请求拦截器
// 所有请求发出去之前会执行的函数，都会处理的逻辑
instance.interceptors.request.use(function (config) {
  // 发起正式请求之前 添加token字段
  const userInfo = getUserInfo()
  if (userInfo && userInfo.token) {
    config.headers.Authorization = `Bearer ${userInfo.token}`
  }
  return config
}, function (error) {
  return Promise.reject(error)
})
```

```js
// 单独的接口函数中不再需要设置token
export const getUserInfo = () => {
  // 返回一个登录的axios请求
  return request({
    url: '/mp/v1_0/user/profile',
    method: 'GET'
  })
}
```

## 页面权限控制

### 1. 背景说明

在我们的项目中，除了登录页面，其它所有页面都需要具有登录状态才能访问，也就是说我们要给这些需要登录才能访问的页面进行统一控制，通常的做法就是利用[路由的导航守卫]([https://router.vuejs.org/zh/guide/advanced/navigation-guards.html)来统一处理

### 2. 技术方案

> 在进入主页路由跳转之前进行身份验证，其实就是检验本地是否有token，如果通过，则可以进入主页，如果不通过就不能进入主页,如果没有token跳回到登录页进行强制登录

```js
import { getUser } from '@/utils/store'
// 添加导航守卫 做页面权限控制
// 守卫逻辑：
// 如果去的是主页 需要进行token验证  如果去的是登录页直接放行
router.beforeEach((to, from, next) => {
  // to:目标路由对象
  // from:来源路由对象
  // next:函数 需要执行才能进行正式的路由跳转
  console.log(to)
  if (to.path === '/home') {
    // 进行权限验证
    // 如果当前有token数据 就放行 如果没有就跳回到登录页面
    const userInfo = getUser()
    if (userInfo && userInfo.token) {
      next()
    } else {
      next('/login')
    }
  } else {
    next()
  }
})
```

## 实现登出功能

### 1.  给退出按钮注册点击事件

```html
<!-- 具名插槽：设置下拉菜单的内容 -->
<el-dropdown-menu slot="dropdown">
    <el-dropdown-item>设置</el-dropdown-item>
    <el-dropdown-item @click.native="quit">退出</el-dropdown-item>
</el-dropdown-menu>
```

> 注意：并不是所有的组件在注册事件的时候需要使用 `.native` 修饰符，例如 el-button 组件注册点击事件就不需要，这主要是因为该组件内部处理了
>
> 什么时候使用 `.native`？首先肯定是在组件上注册事件可能会用到，如果普通方式注册不上，这个时候加 `.native` 修饰符
>
> 例如你给一个组件注册一个 `input` 事件，如果直接 `@input` 注册无效，那就试一下 `@input.native`

### 2.  退出逻辑编写

1. 提问用户是否真的要退出
2. 清空本地token数据
3. 跳转到登陆页面

```js
import { delUserInfo } from '@/utils/store'
logOut () {
  // 1.清除本地的token数据
  // 2.跳回到登录页面
  this.$confirm('确定要登出吗？', '提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
  }).then(() => {
    delUserInfo()
    this.$router.push({
      path: '/login'
    })
  }).catch(() => {
    // 用户取消了
  })
}
```

## 文章管理模块

### 1. 文章页面布局

#### 1.1 上下大模块划分

`el-card`

```html
<!-- 上部搜索条件区域 -->
<el-card class="filter-card">
    <div slot="header"></div>
</el-card>
<!-- 下部文章列表区域 -->
<el-card class="box-card">
    <div slot="header"></div>
</el-card>
```

#### 1.2 上部 - 添加面包屑导航

`el-breadcrumb`

```html
<el-card class="filter-card">
    <div slot="header">
    	<el-breadcrumb separator-class="el-icon-arrow-right">
          <el-breadcrumb-item>首页</el-breadcrumb-item>
          <el-breadcrumb-item>内容管理</el-breadcrumb-item>
        </el-breadcrumb>
    </div>
</el-card>
```

#### 1.2 上部 - 添加查询条件表单

`el-form`

```html
<el-card class="filter-card">
  <div slot="header">
    <!-- 面包屑路径导航 -->
    <el-breadcrumb separator-class="el-icon-arrow-right">
      <el-breadcrumb-item to="/">首页</el-breadcrumb-item>
      <el-breadcrumb-item>内容管理</el-breadcrumb-item>
    </el-breadcrumb>
    <!-- /面包屑路径导航 -->
  </div>
  <!-- 数据筛选表单 -->
  <el-form ref="form" :model="form" label-width="40px" size="mini">
    <el-form-item label="状态">
      <el-radio-group v-model="form.resource">
        <el-radio label="全部"></el-radio>
        <el-radio label="草稿"></el-radio>
        <el-radio label="待审核"></el-radio>
        <el-radio label="审核通过"></el-radio>
        <el-radio label="审核失败"></el-radio>
        <el-radio label="已删除"></el-radio>
      </el-radio-group>
    </el-form-item>
    <el-form-item label="频道">
      <el-select v-model="form.region" placeholder="请选择频道">
        <el-option label="频道一" value="shanghai"></el-option>
        <el-option label="频道二" value="beijing"></el-option>
      </el-select>
    </el-form-item>
    <el-form-item label="日期">
      <el-date-picker
        v-model="form.date1"
        type="datetimerange"
        start-placeholder="开始日期"
        end-placeholder="结束日期"
        :default-time="['12:00:00']">
      </el-date-picker>
    </el-form-item>
    <el-form-item>
      <el-button type="primary" @click="onSubmit">查询</el-button>
    </el-form-item>
  </el-form>
  <!-- /数据筛选表单 -->
</el-card>
```

#### 1.3 下部 - 添加文章列表

`el-table`

`el-pagination`

```html
 <el-card class="box-card">
  <div slot="header" class="clearfix">
    根据筛选条件共查询到 46147 条结果：
  </div>
  <!-- 数据列表 -->
  <el-table
    :data="tableData"
    stripe
    style="width: 100%"
    class="list-table"
    size="mini"
  >
    <el-table-column
      prop="date"
      label="日期"
      width="180">
    </el-table-column>
    <el-table-column
      prop="name"
      label="姓名"
      width="180">
    </el-table-column>
    <el-table-column
      prop="address"
      label="地址">
    </el-table-column>
  </el-table>
  <!-- /数据列表 -->
  <!-- 列表分页 -->
  <el-pagination
    layout="prev, pager, next"
    background
    :total="1000">
  </el-pagination>
  <!-- /列表分页 -->
</el-card>
```

### 2. 获取文章数据

#### 2.1 封装请求文章接口方法

```js
import request from '@/utils/request'

// 1.查询文章
// params参数代表查询字符串对象
export const getArticle = (params) => {
  return ajax({
    method: 'GET',
    url: '/mp/v1_0/articles',
    params
  })
}
```

#### 2.2 调用方法请求数据

##### 1. 导入方法

```js
import { getArticles } from '@/api/article'
```

##### 2. 添加数据项

```js
data () {
    return {
      articles: [] // 文章列表
    }
}
```

##### 3. 添加methods在mounted中调用

```js
methods: {
    loadArticles () {
      getArticle().then(res => {
        this.articles = res.data.data.results
      })
    }
},
mounted () {
	this.loadArticles()
}
```

##### 4. 查看结果是否正确返回

```
chrome -> network -> xhr
```

#### 2.3 表格组件数据绑定

- 将表格组件的**data属性**置成我们取出回来的数据
- 根据数据结构，设置对应列的prop值

```html
<el-table
    :data="articles"
    style="width: 100%">
    <el-table-column
      prop="cover"
      label="封面"
    >
    </el-table-column>
    <el-table-column
      prop="title"
      label="标题"
    >
    </el-table-column>
    <el-table-column
      prop="status"
      label="状态"
    >
    </el-table-column>
    <el-table-column
      prop="pubdate"
      label="发布时间"
    >
    </el-table-column>
    <el-table-column
      prop="address"
      label="操作">
    </el-table-column>
 </el-table>
```

问题一：遇到没办法直接使用到列上的字段怎么办？

`el-image`

```html
<!-- 
 比如说封面，我们需要的是里面的images，这种情况我们需要用到自定义列
 cover: {type: 0, images: []}
-->
<template slot-scope="scope">
    <el-image
      :src="scope.row.cover.images[0]"
      style="width:150px;height:100px"
      lazy
      >
        <div slot="placeholder" class="image-slot">
            加载中<span class="dot">...</span>
        </div>
    </el-image>
 </template>
```

问题二：遇到多种状态对应多种视图应该怎么办？

```html
<!-- 
由于后端回传的数据是数值，而我们视图要显示的是一个带有颜色的tag
文章状态:
 0-草稿，1-待审核，2-审核通过，3-审核失败，4-已删除
-->
<el-table-column
     label="状态"
     >
    <template slot-scope="scope">
        <el-tag v-if="scope.row.status===0">草稿</el-tag>
        <el-tag v-else-if="scope.row.status===1" type="info">待审核</el-tag>
        <el-tag v-else-if="scope.row.status===2" type="success">审核通过</el-tag>
        <el-tag v-else-if="scope.row.status===3" type="warning">审核失败</el-tag>
        <el-tag v-else-if="scope.row.status===4" type="danger">已删除</el-tag>
    </template>
</el-table-column>

<!--补充一个方案
formatStatus (status) {
  const statusObj = {
    0: '草稿',
    1: '待审核',
    2: '审核通过',
    3: '审核失败',
    4: '已删除'
  }
  return statusObj[status]
}
{{formatStatus(scope.row.status)}}
-->
```

问题三：操作区域多种按钮显示

```html
<el-table-column
    label="操作">
    <template slot-scope="scope">
        <el-button
           size="mini"
           icon="el-icon-edit"
           type="primary"
           circle
           @click="edit(scope.$index, scope.row)"></el-button>
        <el-button
           size="mini"
           type="danger"
           icon="el-icon-delete"
           circle
           @click="del(scope.$index, scope.row)"></el-button>
    </template>
</el-table-column>
<!-- 
 说明：
 scope.$index表示当前行的行索引（从0开始）
 scope.row表示当前行的数据对象
-->
```

#### 2.4 数据分页

##### 1. 分页的目的

> 缓解查询数据的压力  提高页面的响应速度
>
> 数据量小的时候有可能前端来做分页  大部分场景都是后端来做  后端适合做计算  前端适合做交互

##### 2. element分页的结构

```html
<!-- 分页组件
    1. total是总条数数
    默认情况，它会以每页10条进行计算总页数
    2. current-change	当点击页码时触发方法并且把当前的页码值自动传入
-->
<el-pagination
   style="margin-top:10px;"
   background
   layout="prev, pager, next"
   @current-change="hPageChange"
   :total="56">
</el-pagination>
```

##### 3. 监听页数点击事件

```js
methods:{
  hPageChange(curPage){
    console.log(curPage)
  }  
}
```

##### 4. 设置总条数

第一步：添加数据项

```diff
data () {
    return {
+     total_count: 0, // 当前查询能查到的总条数
      articles: [] // 文章列表
    }
  }
```

第二步：设置数据项

```diff
loadAricles () {
      // 调用导入的方法
      getArticles().then(res => {
        this.articles = res.data.data.results
        // 保存总数
+        this.total_count = res.data.data.total_count
      })
    }
```

第三步：绑定数据项 

```diff
<el-pagination
     style="margin-top:10px;"
     background
     layout="prev, pager, next"
     @current-change="hPageChange"
     :page-size="10"
+    :total="total_count">
</el-pagination>
```

##### 5. 获取分页数据

第一步：补足一个数据项，保存当前查询页码

 ```diff
return {
+ curPage: 1, // 当前要查询的页码默认为1
  total_count: 0, // 当前查询能查到的总条数
  articles: [] // 文章列表
}
 ```

第二步：改造查询函数，传入当前页码

```diff
loadAricles () {
  // 调用导入的方法
  // 补充一个查询参数 page
  getArticles({
+   page: this.curPage
  }).then(res => {
    this.articles = res.data.data.results
    // 保存总数
    this.total_count = res.data.data.total_count
  })
}
```

第三步：击点页码时，更新当前要查询页码，并重发请求

```js
pageChange (curPage) {
  // 1. 更新当前页码
  this.curPage = curPage
  // 2. 再发请求
  this.loadAricles()
}
```

##### 6. 统计数据显示

```html
<div slot="header">
     根据筛选条件查询到{{total_count}}条数据,当前是第{{curPage}}页
</div>
```

### 3. 筛选文章数据

#### 产品逻辑梳理

1. 确定筛选条件 （确认你要访问哪些条件下的数据  默认状态下访问全部数据）
2. 将筛选条件当成接口参数传递给后端 （后端拿到筛选字段之后在数据库中做匹配过滤 将符合条件的数据返给前端）
3. 前端拿到数据之后做数据渲染
4. 翻页逻辑
   翻页时请求数据是在当前搜索条件下进行的翻页请求

#### 3.1 按状态筛选

##### 添加数据

```js
data(){
	return {
		status: null // 文章状态 不传就是全部
    }
}
```

##### 绑定视图

```html
<el-form-item label="状态">
  <!-- label用来决定选择项被选中之后，它表示的值 -->
  <el-radio-group v-model="form.status">
    <el-radio :label="null">全部</el-radio>
    <el-radio :label="0">草稿</el-radio>
    <el-radio :label="1">待审核</el-radio>
    <el-radio :label="2">审核通过</el-radio>
    <el-radio :label="3">审核失败</el-radio>
    <el-radio :label="4">已删除</el-radio>
  </el-radio-group>
</el-form-item>
```

##### 补充参数到查询方法

```js
loadArticles () {
  getArticles({
    status: this.form.status,
    page: this.curPage
  }).then(res => {
    this.articles = res.data.data.results
    this.total_count = res.data.data.total_count
  })
}
```

#### 3.2 按频道筛选

##### 封装数据接口

 `api/article.js` 

```js
/**
 * 获取文章频道
 */
export const getArticleChannels = () => {
  return request({
    method: 'GET',
    url: '/mp/v1_0/channels'
  })
}
```

##### 请求获取频道数据

`src/views/Article/index.vue`

```js
import { getArticles, getArticleChannels } from '@/api/article'
export default {
    data(){
        return {
             channels: [], // 频道列表
        }
    },
    methods: {
     loadChanels () {
       getArticleChannels().then(res => {
        // console.log('获取频道的数据', res)
        this.channels = res.data.data.channels
       })
      }
    }
    mounted(){
        this.loadChanels()
    }
}
```

##### 双向绑定到视图

补充数据项，用来保存用户选中当前上频道

```js
form: {
    channelId: null, // 下拉列表选中的值
    status: null // 查询文章的状态，默认为null
}
```

视图结构如下

```html
<el-form-item label="频道">
  <!-- clearable： 表示可清空的单选 -->
  <el-select v-model="form.channelId" clearable placeholder="请选择频道">
    <el-option
    v-for="channel in channels"
    :key="channel.id"
    :label="channel.name"
    :value="channel.id"></el-option>
  </el-select>
</el-form-item>
```

##### 传递参数处理筛选

```js
loadArticles () {
  getArticles({
    channel_id: this.form.channelId || null
    status: this.form.status,
    begin_pubdate: beginPubdate,
    end_pubdate: endPubdate,
    page: this.curPage
  }).then(res => {
    this.articles = res.data.data.results
    // 保存总数
    this.total_count = res.data.data.total_count
  })
}
```

#### 3.3 按日期筛选

##### 视图模板

```html
<el-form-item label="日期">
  <el-date-picker
      v-model="form.date"
      type="daterange"
      value-format="yyyy-MM-dd"
      range-separator="至"
      start-placeholder="开始日期"
      end-placeholder="结束日期">
  </el-date-picker>
</el-form-item>
```
##### 日期参数增加
```js
loadArticles () {
  // 做容错处理 当不选择时间date是null
  // null如果做获取操作会报错
  if (this.form.date === null) {
    this.form.begin_pubdate = ''
    this.form.end_pubdate = ''
  } else {
    this.form.begin_pubdate = this.form.date[0]
    this.form.end_pubdate = this.form.date[1]
  }
  getArticle({
    begin_pubdate: beginPubdate,
    end_pubdate: endPubdate,
    status: this.form.status,
    channel_id: this.form.channelId || null,
    page: this.curPage
  }).then(res => {
    this.articles = res.data.data.results
    this.total_count = res.data.data.total_count
  })
}
```



### 4. 文章删除功能实现

#### 4.1 请求接口

`src/api/article.js`

```JS
export const delArticle = function(articleId){
  return request({
    url:`/mp/v1_0/articles/${articleId}`,
    method:'DELETE'
  })
}
```

#### 4.2 调用接口获取数据

`src/article/index.vue`

```js
handleDelete(index,row){
    delArticle(row.id).then(res=>{
       console.log(res)
    })
}
```

#### 4.3. 大数问题

##### 现象

```
接口发给后端的id:  1294207633846173700
文章实际的id:  1294207633846173696
居然不一样！！  
失败的原因找到了: 文章id传错了
response -> preview  
JSON.parse json字符串转变成json对象  一旦要转换的数据超过了js最大能接受的数值范围就会出现精度问题 
```

##### 本质

1.  JavaScript 能够准确表示的整数范围在`-2^53`到`2^53`之间（不含两个端点），超过这个范围，无法精确表示这个值，这使得 JavaScript 不适合进行科学和金融方面的精确计算

2. Axios请求库内部会使用JSON.parse方法进行一次数据转换，转换的过程中如果遇到'大数'就会出现问题

##### 解决方案

`json-bigint`

1. 安装插件

   ```bash
   npm i json-bigint -S
   ```

2. 简单使用

   `main.js`

   ```js
   import JSONbig from 'json-bigint'
   const str = '{ "id": 1253585734669959168 }'
   console.log(JSON.parse(str)) // 1253585734669959200
   console.log(JSONbig.parse(str).id.toString()) //1253585734669959168
   ```

3. 项目应用

   ```js
   /* 思路：
   Axios 会在内部使用 JSON.parse 把后端返回的数据转为 JavaScript 数据对象,就可能出现大数问题
   所以解决思路就是不要让 axios 使用 JSON.parse 来转换这个数据，而是使用 json-biginit 来做转换处理
   axios 提供了一个 API：transformResponse，它是一个数组，其中每个成员就是一个函数，作用是当数据请求回来之后，做进一步的处理
   */
   
   import JSONbig from 'json-bigint'
   
   const request = axios.create({
     // 当前项目的所有接口都是以这个地址开头的
     baseURL: 'http://ttapi.research.itcast.cn/',
     transformResponse: [function (data) {
       // Do whatever you want to transform the data
       // console.log('transformResponse', data)
       try {
         return JSONbig.parse(data)
       } catch (err) {
         console.log('JSONbig转换出错', err)
         return data
       }
     }]
   })
   ```

4. 验证结果

   ```js
   // 删除文章
   handleDelete(index,row){
       const id = row.id.toString()
       console.log(id) // 对比id和获取回来的id是否变成一致的了
       delArticle(id).then(res=>{})
   }
   ```

## 项目期中作业

- [ ]  独立完成评论管理模块 （课上不讲）
- [ ]  前四天项目相关的东西过一遍 （有问题甩到我QQ）
- [ ]  尝试完成素材管理 （课上还会讲）

## 素材管理模块

### 1. 整体页面布局

`el-radio-group`

`el-row`

```html
<template>
  <div class="image-container">
    <el-card class="box-card">
      <div slot="header">
       <el-breadcrumb separator-class="el-icon-arrow-right">
          <el-breadcrumb-item to="/">首页</el-breadcrumb-item>
          <el-breadcrumb-item>素材管理</el-breadcrumb-item>
        </el-breadcrumb>
      </div>
      <div style="padding-bottom: 20px;">
        <el-radio-group v-model="radio1" size="mini">
          <el-radio-button label="全部"></el-radio-button>
          <el-radio-button label="收藏"></el-radio-button>
        </el-radio-group>
        <el-button size="mini" type="success" style="float:right;">上传图片素材</el-button>
      </div>
      <!-- 素材列表 -->
      <el-row :gutter="10">
        <el-col  class="img_item" :xs="12" :sm="6" :md="6" :lg="4">
          <div class="img_box">
           <img src="https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg" alt="">
          </div>
          <div class="option">
            <span class="el-icon-star-off"></span>
            <span class="el-icon-delete"></span>
          </div>
        </el-col>
      </el-row>
      <!-- /素材列表 -->
    </el-card>
  </div>
</template>

<script>
export default {
  data () {
    return {
      radio1: '全部'
    }
  }
}
</script>

<style lang="less" scoped>
  .img_item {
    position: relative;
    box-sizing: border-box;
    .img_box{
      height: 180px;
      img{
        width: 100%;
        height: 100%;
      }
    }
  }
  .option {
    position: absolute;
    left: 5px;
    right:5px;
    bottom: 5px;
    height: 30px;
    background: rgba(0, 0, 0, 0.3);
    color: #fff;
    display: flex;
    span {
      flex:1;
      text-align: center;
      cursor: pointer;
      line-height: 30px;
    }
  }
.avatar-uploader {
    text-align: center;
}
.avatar-uploader-icon {
    font-size: 28px;
    color: #8c939d;
    width: 178px;
    height: 178px;
    line-height: 178px;
    text-align: center;
}
.avatar-uploader{
  /deep/ .el-upload {
    border: 1px dashed #d9d9d9;
    border-radius: 6px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
 }
}
</style>

```

### 2. 基础数据显示

#### 2.1 封装获取图片接口

```js
/**
 * 封装素材相关操作
 */
 import request from '@/utils/request.js'
 export const getImages = (params) => {
   return request({
     method: 'GET',
     url: '/mp/v1_0/user/images',
     params
   })
 }

```

#### 2.2 调用接口并显示数据

##### 1. 脚本逻辑编写

```js
// 1. 导入方法
import { getImages} from '@/api/image'

export default {
    data(){
        return {
            // 2.添加数据项
            images: [] // 素材列表
        }
    },
    methods:{
        loadImages(){
            getImages().then(res=>{
                this.images = res.data.data.results
            })
        }
    },
    mounted(){
        this.loadImages()
    }
}

```

##### 2. 数据模板绑定

```html
<!-- 素材列表 -->
 <el-row :gutter="10">
    <!-- image 是个自定义的变量   imageList是个data中的数据 -->
    <el-col v-for="image in imageList" :key="image.id" class="img_item" :xs="12" :sm="6" :md="6" :lg="4">
      <div class="img_box">
       <img :src="image.url" alt="">
      </div>
      <div class="option">
        <!-- 
          image.is_collected  true  false
          当image.is_collected 为true时文字颜色渲染为红色代表已经收藏过了
          当imgae.is_coloected 为false时文字颜色渲染为白色代表没有收藏过
         -->
        <span class="el-icon-star-off" :style="{color:image.is_collected ? 'red': '#fff'}"></span>
        <span class="el-icon-delete"></span>
      </div>
    </el-col>
  </el-row>
<!-- /素材列表 -->
```

### 3. 分页功能实现

#### 3.1  引入分页组件

```html
<el-pagination
    style="margin-top:10px;"
    background
    layout="prev, pager, next"
    @current-change="pageChange"
    :page-size="per_page"
    :total="total_count">
 </el-pagination>
```

#### 3.2 添加分页数据

```diff
data () {
    return {
      radio1: '全部',
      images: [], // 素材列表
+     cur_page: 1,
+     total_count: 0,
+     per_page: 10
    }
}
```

#### 3.3 添加页数切换方法

```js
 pageChange (curPage) {
  // alert(curPage)
  // 1. 更新查询参数
  this.cur_page = curPage
  // 2. 再发请求
  this.loadImages()
}
```

#### 3.4 添加请求参数

```js
loadImages(){
    getImages({
       per_page: this.per_page, // 每页几条
       page: this.cur_page // 请求的页码
    }).then(res=>{
        this.images = res.data.data.results
        this.total_count = res.data.data.total_count
    })
}
```

### 4. 数据筛选实现

> 思路：点击按钮切换的时候，传给后端不同的参数即可

#### 4.1 设置数据项 记录当前选择

```diff
data () {
    return {
      images: [],
+     collect: false, // true收藏，false全部
      total_count: 0, // 本次查询结果总数
      cur_page: 1, // 当前页码
      per_page: 10 // 一页10张图
    }
}
```

#### 4.2 视图绑定数据项

```html
<div style="padding-bottom:20px;">
    <!-- 对于数据项：collect: false
          当选中全部时，它的值是false
          当选中收藏时，它的值是true
        对于el-radio组件，可以通过label来设置当前项被中时的值
        :label="false" 表示一个布尔值 false
        label="false"  表示一个普通的字符串 'false'
    -->
    <el-radio-group v-model="collect" @change="collectChange">
      <el-radio-button :label="false">全部</el-radio-button>
      <el-radio-button :label="true">收藏</el-radio-button>
    </el-radio-group>
 </div>
```

#### 4.3 切换事件

```js
collectChange () {
  // 全部&收藏 的切换
  console.log(this.collect)
  // 重发请求
  this.loadImages()
}
```

#### 4.4 修改传参

```diff
loadImages () {
     getImages({
+      collect: this.collect, // 是否是收藏
       per_page: this.per_page, // 每页几条
       page: this.cur_page // 请求的页码
    }).then(res=>{
        this.images = res.data.data.results
        this.total_count = res.data.data.total_count
    })
}
```

### 5. 收藏和取消收藏

#### 5.1 添加接口方法

```js
/**
 * 切换收藏图片
 * @param {*} id 图片的编号
 * @param {*} collect  是否收藏
 */
export const switchCollect = (id, collect) => {
  return request({
    method: 'PUT',
    url: '/mp/v1_0/user/images/' + id,
    data: {
      collect
    }
  })
}
```

#### 5.2 添加事件处理函数

```js
switchCollect (image) {
    const { id, is_collected } = image
    switchCollect(id, !is_collected).then(res => {
        this.$message.success('操作成功')
        // 更新视图
        // 有两种方案：
        // 方案1. 整个更新数据，就是重新请求。 成本高，不划算
        // this.loadImages()
        // 方案2. 只更新当前这个图片的数据项。
        // image是一个对象，就是当前被点击那张图片你改了这些的数据，则images中的数据也改了
        image.is_collected = !is_collected
    }).catch {
    	this.$message.error('操作失败')
    }
}
```

#### 5.3 更改UI展示

```html
<!-- 是否收藏 -->
<!-- 
  image.is_collected  true  false
  当image.is_collected 为true时文字颜色渲染为红色代表已经收藏过了
  当imgae.is_coloected 为false时文字颜色渲染为白色代表没有收藏过
-->
<span
  :style="{color:image.is_collected ? 'red': '#fff'}"
  class="el-icon-star-off"
  @click="switchCollect(image)">
</span>
```

### 6. 实现删除功能

#### 6.1 准备删除方法

```js
/**
 * 删除图片
 * @param {*} id 图片编号
 */
export const deleteImage = id => request({ 
    method: 'DELETE', 
    url: '/mp/v1_0/user/images/' + id 
})
```

#### 6.2 注册点击事件

```html
<span class="el-icon-delete" @click="del(image.id, idx)"></span>
```

#### 6.3 删除动作

```js
// 删除图片
del (id, idx) {
  deleteImage(id).then(res => {
    this.$message.success('删除成功')
    // 删除本地当前数据项
    this.images.splice(idx, 1)
  }).catch(() => {
    this.$message.error('删除失败')
  })
}
```

### 6.4 小结

> 遇到操作list中的一个数据的状态时，我们往往不会去重新拉取一边数据，因为这样会耗费网络性能，体验也不会，所以我们一般分两步操作
>
> 1.调用接口更新后端数据库
>
> 2.操作本地数据让数据状态和数据库一致

### 7. 上传功能实现

> 使用[对话框组件](https://element.eleme.cn/#/zh-CN/component/dialog#dialog-dui-hua-kuang) 弹出层
>
> 使用文件上传组件来上传图片

`el-dialog`

#### 7.1 基本布局

```html
<div style="padding-bottom:20px;">
    <el-radio-group v-model="collect" @change="hCollectChange">
        <el-radio-button :label="false">全部</el-radio-button>
        <el-radio-button :label="true">收藏</el-radio-button>
    </el-radio-group>

    <el-button
         @click="dialogVisible=true"
         type="success" size="mini" style="float:right">
        上传图片素材          
    </el-button>
</div>
<!-- 
上传图片文件的对话框 
append-to-body: 让这个弹出层在最上面不要被其它元素挡住
-->
<el-dialog
  title="提示"
  :append-to-body="true"
  :visible.sync="dialogVisible"
  >
  <span>上传图片</span>
</el-dialog>
```

#### 7.2 补充数据项

```diff
data () {
    return {
+     dialogVisible: false, // 是否显示弹出对话框
      images: [],
      collect: false, // 是否是 收藏的图片， true表示是收藏，false表示是全部
      total_count: 0, // 本次查询结果总数
      cur_page: 1, // 当前页码
      per_page: 10 // 一页10张图
    }
}
```

#### 7.3 使用 el-upload 上传

[参考效果](https://element.eleme.cn/#/zh-CN/component/upload#yong-hu-tou-xiang-shang-chuan)

##### 1. el-upload的属性

- action： 必选参数，上传的地址：http://ttapi.research.itcast.cn/mp/v1_0/user/images
- headers: 设置上传的请求头部。要携带token
- name：上传的文件字段名。要与接口中要求保持一致。
- show-file-list： 是否显示已上传文件列表
- before-upload: 上传之前对文件进行检测
- on-success：文件上传成功时的钩子  `function(response, file, fileList)`

##### 2. 页面结构

```html
<!-- 上传图片文件的对话框 -->
<el-dialog
  title="提示"
  :append-to-body="true"
  :visible.sync="dialogVisible"
  >
  <!--
    action：上传地址
    show-file-list:false，不需要显示已上传的文件列表
    on-success： 上传成功之后的回调函数
    before-upload: 上传之前对文件进行检测
    name: 设置上传的文件参数名，要与后端接口中的要求一致。
  -->
  <el-upload
    class="avatar-uploader"
    action="http://ttapi.research.itcast.cn/mp/v1_0/user/images"
    :headers="headers"
    :on-success="hUploadSuccess"
    name="image"
    :show-file-list="false"
    :before-upload="beforeAvatarUpload">
    <!-- 如果当前有预览地址就说明图片上传成功了。 -->
    <img v-if="imgSrc" :src="imgSrc" class="avatar">
    <i v-else class="el-icon-plus avatar-uploader-icon"></i>
  </el-upload>
 </el-dialog>
```

##### 3. 补充数据项

```js
// 由于这里的上传不是走的axios,而处理上传的接口又需要token
// 所以这里只能手动添加token
import { getUser } from '@/utils/store'
export default {
    data(){
        return {
            imgSrc: null,
            headers: {
              Authorization: `Bearer ${getUser().token}`
            }
        }
    }
}
```

##### 4. 设置回调

```js
beforeAvatarUpload (file) {
  const isJPG = file.type === 'image/jpeg'
  const isLt2M = file.size / 1024 / 1024 < 2
  if (!isJPG) {
    this.$message.error('图片只能是 JPG 格式!')
  }
  if (!isLt2M) {
    this.$message.error('图片大小不能超过 2MB!')
  }
  return isJPG && isLt2M
},
// 如果上传成功，则会把响应结果传给res
uploadSuccess (res) {
  console.log(res)
  // 保存上传成功之后的图片地址
  this.imgSrc = res.data.url
  this.$message.success('上传素材成功')
  this.loadImages()
}
```

## 文章发布模块

### 1. 基础发布功能

#### 1.1 基础模板和数据

```html
<template>
  <div class="publish-container">
    <el-card>
      <div slot="header" class="clearfix">
        <el-breadcrumb separator-class="el-icon-arrow-right">
          <el-breadcrumb-item :to="{ path: '/' }">首页</el-breadcrumb-item>
          <el-breadcrumb-item>发布文章</el-breadcrumb-item>
        </el-breadcrumb>
      </div>
      <el-form ref="form" :rules="rules" :model="article" label-width="80px">
        <el-form-item label="标题" prop="title">
          <el-input v-model.trim="article.title"></el-input>
        </el-form-item>
        <el-form-item label="内容：" prop="content">
            
        </el-form-item>
        <el-form-item label="封面">
          <el-radio-group v-model="article.cover.type">
            <!-- 根据后端接口约定 -->
            <el-radio :label="0">无图</el-radio>
            <el-radio :label="1">单图</el-radio>
            <el-radio :label="3">三图</el-radio>
            <el-radio :label="-1">自动</el-radio>
          </el-radio-group>
        </el-form-item>
        <el-form-item label="频道" prop="channel_id">
          <el-select v-model="article.channel_id" placeholder="请选择活动区域">
            <el-option
              v-for="channel in channels"
              :key="channel.id"
              :label="channel.name"
              :value="channel.id"
            ></el-option>
          </el-select>
        </el-form-item>
       <el-form-item>
          <el-button type="primary" @click="hAddArticle(false)">发表</el-button>
          <el-button @click="hAddArticle(true)">存入草稿</el-button>
        </el-form-item>
      </el-form>
    </el-card>
  </div>
</template>
<script>

export default {
  data() {
    return {
      channels: [],
      article: {
        title: '', // 文章村里
        content: '', // 文章内容
        cover: {
          type: 0, // 封面图片的张数
          images: [], // 封面的地址
        },
        channel_id: '' // 频道id
      }
  },
  methods: {
    hGetChannels() {
    },
    hAddArticle(isDraft){
    }
  },
  mounted(){
    this.hGetChannels()
  }
}
```

#### 1.2 请求频道数据

```js
import { getChannels } from "@/api/article"
export default{
    methods:{
     hGetChannels() {
          getChannels().then((res) => {
            // 赋值给响应式数据
            this.channels = res.data.data.channels
          })
          .catch((err) => {
            console.log(err)
          })
        }
    },
    mounted(){
        this.hGetChannels() 
    }
}
```

#### 1.3 使用富文本编辑器

https://github.surmon.me/vue-quill-editor/

##### 安装

```bash
npm install vue-quill-editor -S
```

##### 引入

```js
import { quillEditor } from "vue-quill-editor"
import "quill/dist/quill.core.css"
import "quill/dist/quill.snow.css"
import "quill/dist/quill.bubble.css"
```

##### 使用

```js
// 注册
components:{ quillEditor }

// 准备配置项
data(){
    return {
        editorOption: {
            placeholder: '',//占位文字
            modules: {
              toolbar: [
                ["bold", "italic", "underline", "strike"],
                ["blockquote", "code-block"],
                [{ header: 1 }, { header: 2 }],
                [{ list: "ordered" }, { list: "bullet" }],
                [{ indent: "-1" }, { indent: "+1" }],
                ["image"]
              ]
            }
        }
    }
}

// 模板中使用
<quill-editor v-model="article.content" :options="editorOption"></quill-editor>
```

#### 1.4 完成添加文章基础功能

```js
import { getChannels, addArticle } from "@/api/article"
export default {
    methods:{
    // 创建文章
    hAddArticle (draft) {
      // query参数
      const params = {
        draft
      }
      // body参数
      const data = this.article
      createArticle(params, data).then(res => {
        console.log(res)
        this.$message({
          type: 'success',
          message: '创建文章成功'
        })
      })
    }
  }
}
```

### 2. 添加校验规则

```js
// 1.模板添加prop属性

// 2.添加校验规则
data(){
    return {
      rules: {
        title: [
          { required: true, message: '请输入文章标题', trigger: 'blur' },
          { min: 5, max: 30, message: '长度在5到30之间', trigger: 'blur' }
        ],
        content: [
          { required: true, message: '请输入文章内容', trigger: 'blur' },
          { min: 20, max: 30000, message: '最少20个字', trigger: 'blur' }
        ],
        channel_id: [
          { required: true, message: '请选择文章频道', trigger: 'blur' }
        ]
      }
    }
}
// 3.提交数据之前先进行校验
hAddArticle(isDraft){
  this.$refs.form.validate((valid) => {
     if(valid){
      this.article.cover.images = this.$refs.cover.getPicList()
      addArticle(isDraft, this.article).then(res=>{
        this.$message.success('发布成功')
        // 清空发布区域
        this.article.title = ''
        this.article.content = ''
        this.article.cover = {
          type: 0,
          images: []
        }
      })
     }else{
       return false
     }
  })
```

### 3. 添加封面功能（难点）

#### 3.1 组件编写

`src/views/article/Cover.vue`

##### 思路分析

问题1

Cover中的图片显示数据是用父组件中的数据传进去的，所以需要用到父传子

```html
<!-- 父组件 -->
<Cover :picUrl="getUrl"/>
<!-- 子组件 -->
props:{
  picUrl:{
   type:String
  }
}
```

问题2

 article.cover.images是最终要传给后端的数据，所以要求我们在Cover组件中选中的图片要赋值到images中，所以需要用到子传父

```html
<!-- 父组件 -->
<Cover @get-url="getUrl"/>
export default {
  methods:{
	getUrl(url){
	  // 接受子组件传过来的值
    }
  }
}
<!-- 子组件 -->
this.$emit('get-url','图片地址')
```

综上可知：无非是想在子组件中修改props中的值，有没有更加简单的方式？？

**sync修饰符**

```html
<!-- 父组件 -->
<Cover :picUrl.sync = "url">
<!-- 子组件 -->
<!-- 选中图片之后调用此方法把地址传出来 -->
this.$emit('update:picUrl', this.curImage.url)
```

##### 编写组件静态页面

说明：弹出框中大部分的代码都是素材管理模块中的源代码，直接拿过来即可

```html
<template>
  <div class="my-cover">
     <div class="operateBox" @click="dialogVisible = true">
       <span>选择素材</span>
       <img src="" alt="" class="img">
     </div>
    <!-- 对话框 -->
    <el-dialog
      :append-to-body="true"
      :visible.sync="dialogVisible"
      width="720px">
      <el-card class="box-card">
        <div style="padding-bottom: 20px;">
          <el-radio-group v-model="collect" size="mini" @change="collectChange">
            <el-radio-button :label="false">全部</el-radio-button>
            <el-radio-button :label="true">收藏</el-radio-button>
          </el-radio-group>
        </div>
        <el-row :gutter="10">
          <el-col
            v-for="(image) in imageList"
            :key="image.id" class="img_item" :xs="12" :sm="6" :md="6" :lg="4">
            <div class="img_box">
              <img :src="image.url" alt="">
              <div class="selected">
                <img src="./img/selected.png" alt="">
              </div>
            </div>
          </el-col>
        </el-row>
        <el-pagination
          style="margin-top:10px;"
          background
          layout="sizes, prev, pager, next"
          :page-sizes="[5, 10, 15, 20]"
          :page-size="10"
          @current-change="currentChange"
          @size-change="sizeChange"
          :total="total_cont">
        </el-pagination>
      </el-card>
      <span slot="footer" class="dialog-footer">
        <el-button @click="cancel">取 消</el-button>
        <el-button type="primary" @click="confirm">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
// 引入图片素材接口
import { getImageList } from '@/api/image'
export default {
  data () {
    return {
      imageList: [], // 素材列表
      total_cont: 0, // 素材总数
      curPage: 1, // 当前要请求第几页数据
      per_page: 10, // 当前每页的条数
      dialogVisible: false, // 弹出框是否显示
      collect: false // 是否为收藏状态
    }
  },
  methods: {
    openDialog () {
      this.dialogVisible = true
    },
    currentChange (pageNum) {
      this.curPage = pageNum
      this.hGetImage()
    },
    // 发起素材请求列表
    hGetImage () {
      getImageList({
        collect: this.collect,
        per_page: this.per_page, // 每页的条数
        page: this.curPage // 当前请求第几页
      }).then(res => {
        this.imageList = res.data.data.results
        this.total_cont = res.data.data.total_count
      })
    },
    sizeChange (pageSize) {
      this.per_page = pageSize
      this.hGetImage()
    },
    collectChange (collect) {
      this.hGetImage()
    },
    cancel () {},
    confirm () {}
  },
  mounted () {
    this.hGetImage()
  }
}
</script>

<style lang="less" scoped>
.my-cover{
  display: inline-block;
}
.operateBox{
  display: inline-block;
  width: 100px;
  height: 100px;
  margin-left: 10px;
  border-radius: 4px;
  border:1px solid #ccc;
  font-size:13px;
  color:#666;
  text-align: center;
  line-height: 100px;
  overflow: hidden;
  cursor: pointer;
  position: relative;
  .img{
    position: absolute;
    top:0;
    left:0;
    width: 100%;
    height: 100%;
  }
}
  .img_item {
    position: relative;
    box-sizing: border-box;
    .img_box{
      height: 120px;
      margin-bottom: 10px;
       position: relative;
      img{
        width: 100%;
        height: 100%;
      }
      .selected{
        position: absolute;
        width: 20%;
        left:0;
        top:0;
      }
    }
  }
  .option {
    position: absolute;
    left: 5px;
    right:5px;
    bottom: 5px;
    height: 30px;
    background: rgba(0, 0, 0, 0.3);
    color: #fff;
    display: flex;
    span {
      flex:1;
      text-align: center;
      cursor: pointer;
      line-height: 30px;
    }
  }
  .avatar-uploader-icon {
    font-size: 28px;
    color: #8c939d;
    width: 178px;
    height: 178px;
    line-height: 178px;
    text-align: center;
  }
  .uploadBox{
    text-align: center;
    img {
      width:100%;
    }
    // scoped代表当前的样式只能影响当前的组件  影响不了子组件的样式
    // 加上 /deep/ 之后可以进行深度样式控制
    // 当试图直接控制子组件内部元素样式的时候就需要添加 /deep/
    /deep/.el-upload {
      border: 1px dashed #d9d9d9;
      border-radius: 6px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
  }
</style>
```

##### 实现图片数据回显

1. 设计props

   `Cover.vue`

   ```js
   export default {
       props:{
           picUrl:{
               type:String
           }
       }
   }
   ```

2. 传递props（双向绑定的方式）

   `AddArticle.vue`

   ```html
   <Cover :picUrl.sync="图片地址"></Cover>
   ```

3. 完成图片显示

   ```html
    <div class="operateBox" @click="dialogVisible = true">
      <span>选择素材</span>
      <img :src="picUrl" alt="" class="img">
    </div>
   ```

##### 实现子组件修改props中的picUrl

1. 完成图片选择交互功能

   ```diff
   //主要思想:排它思想
   // 1.添加自定义数据
   hGetImage () {
     getImageList({
       collect: this.collect,
       per_page: this.per_page, // 每页的条数
       page: this.curPage // 当前请求第几页
     }).then(res => {
       // 在赋值之前添加一个自定义的属性 专门用来控制对勾的显示
   +    const sourceData = res.data.data.results
   +    const newList = sourceData.map((item) => {
   +      return {
   +        ...item,
   +        isSelected: false
   +     }
       })
       this.imageList = newList
       this.total_cont = res.data.data.total_count
     })
   }
   // 2.使用排它思想
   selectHandle (curItem) {
     // 排他思想先把所有项目的isSelected改为false
     this.imageList.forEach((item) => {
       item.isSelected = false
     })
     // 将当前项中的isSelected改为true
     curItem.isSelected = true
     // 将当前点击的素材赋值到暂存的位置
     this.curImage = curItem
   }
   ```

   

2. 将确定选中的素材数据提交给父组件中

   ```js
   const confirmImageData = this.curImage
   // 正式将确定好的数据提交到父组件中,固定语法
   this.$emit('update:picUrl', confirmImageData.url)
   ```

   

#### 3.2 组件架构图

![整体架构设计](http://cp_fe.gitee.io/assets/vue/架构图6.png)

### 4. 编辑功能

1. 路由跳转传参
2. 回显当前文章数据
3. 修改内容调用更新接口完成文章内容更新

## 粉丝管理模块

### 1. 基本布局

```html
<template>
  <div class="fans-container">
    <el-card>
      <div slot="header">
        <el-breadcrumb separator-class="el-icon-arrow-right">
          <el-breadcrumb-item to="/">首页</el-breadcrumb-item>
          <el-breadcrumb-item>粉丝管理</el-breadcrumb-item>
        </el-breadcrumb>
      </div>
      <!-- tabs组件 -->
      <el-tabs v-model="activeName" type="card">
        <el-tab-pane label="粉丝列表" name="list">
          <!-- 列表 -->
          <div class="fans_list">
            <div class="fans_item">
              <el-avatar :size="80" src="https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png"></el-avatar>
              <p>欧阳娜娜</p>
              <el-button type="primary" plain size="small">+关注</el-button>
            </div>
          </div>
          <!-- 分页 -->
          <el-pagination
            background
            layout="prev, pager, next"
            :page-size="per_page"
            @current-change="changePage"
            :total="total">
          </el-pagination>
        </el-tab-pane>

        <el-tab-pane label="粉丝画像" name="img">
          <div style="width: 600px;height:400px;"></div>
        </el-tab-pane>

      </el-tabs>
    </el-card>
  </div>
</template>

<script>
export default {
  name: 'my-fans',
  data () {
    return {
      activeName: 'list',
      per_page: 20,
      page: 1,
      list: [],
      total: 0,
      circleUrl: 'https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png'
    }
  },
  methods: {
    changePage () {}
  }
}
</script>

<style scoped lang='less'>
.fans_list {
  .fans_item {
    width: 120px;
    height: 170px;
    border: 1px dashed #ddd;
    text-align: center;
    padding-top: 10px;
    display: inline-block;
    margin-right: 30px;
    margin-bottom: 30px;
    p {
      margin: 10px 0;
    }
  }
}
</style>

```

### 2. 粉丝列表功能

#### 2.1 封装接口

`src/api/fans.js`

```js
/**
 * 粉丝模块
*/
import request from '@/utils/request'
export const getFans = (params) => {
  return request({
    method: 'GET',
    url: '/mp/v1_0/followers',
    params
  })
}

```

#### 2.2 在组件中调用接口

`src/views/fans/index.vue`

```js
// 引入
import { getFans } from '@/api/fans'

export default {
  methods: {
    loadFans () {
      const params = {
          page:this.page,
          per_page:this.per_page
      }
      getFans(params).then(res=>{
         this.list = result.data.data.results
      	 this.total = result.data.data.total_count
      }) 
    }
  }，
  // 调用
  mounted(){
     this.loadFans() 
  }
}

```

#### 2.3 页面渲染

```html
<!-- 列表 -->
<div class="fans_list">
   <div class="fans_item"
    v-for="fan in list"
    :key="fan.id">
      <el-avatar
      :size="80"
      :src="fan.photo"></el-avatar>
      <p>{{fan.name}}</p>
      <el-button type="primary" plain size="small">+关注</el-button>
    </div>
</div>
```

#### 2.4 分页功能

```html
<!-- 分页 监听分页事件 -->
  <el-pagination
    background
    layout="prev, pager, next"
    :current-page="page"
    :page-size="per_page"
    @current-change="hChangePage"
    :total="total">
  </el-pagination>
<!-- 方法 -->
<script>
    export default{
      changePage (curPage) {
          // 更新页码
          this.page = curPage
          // 重发请求
          this.loadFans()
        }
    }
</script>
```

### 3. 粉丝画像功能

#### 3.1 引入echart

```bash
npm i echarts --S
```

#### 3.2 基础使用测试

```html
<el-tab-pane label="粉丝画像" name="img">
  <!-- 准备dom容器，让echarts在这里画图
    注意：
    1. 要指定宽，高
    2. 设置ref，方便我们访问这个dom元素
   -->
  <div ref="main" style="width: 600px;height:400px;"></div>
</el-tab-pane>

<script>
// 使用echarts的基本步骤
// 1. 准备dom容器，让echarts在这里画图
// 2. 引入echart
// 3. 画图

import echarts from 'echarts'
    
export default {
    methods:{
        tabClick (tab) {
            if (tab.name === 'img') {
                this.draw()
            }
        },
        draw () {
        // 用echarts来画图
        // 1. 初始化echarts对象
        // 格式： const echartobj = echarts.init(dom结构)
        // 2. 通过固定格式的option来画图
        // echartobj.setOption(option)
        // 基于准备好的dom，初始化echarts实例
        const myChart = echarts.init(this.$refs.main)
        // 指定图表的配置项和数据
        const option = {
            xAxis: {
                type: 'category',
                // X轴数据项
                data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
            },
            yAxis: {
                type: 'value'
            },
            series: [{
                // Y轴数据项
                data: [120, 200, 150, 80, 70, 110, 130],
                type: 'bar',
                showBackground: true,
                backgroundStyle: {
                    color: 'rgba(220, 220, 220, 0.8)'
                }
            }]
        }
         // 使用刚指定的配置项和数据显示图表
         myChart.setOption(option)
       }
    }
}
</script>
```

#### 3.3 用真实数据填充

##### 封装接口

```js
/**
 * 获取粉丝列表统计数据
 */
export const getFansStatistics = () => {
  return request({
    method: 'GET',
    url: '/mp/v1_0/statistics/followers'
  })
}
```

#### 填充数据

```js
tabClick (tab) {
  if (tab.name === 'img') {
    this.draw()
  }
},
draw () {
  // 去取回真实的数据
  const that = this
  getFansStatistics().then(res => {
    initChart(res)
  })
  function initChart (res) {
    const ages = res.data.data.age
    const ageY = []
    const ageX = []
    for (const key in ages) {
      ageY.push(ages[key])
      ageX.push(key.replace('le', '小于').replace('gt', '大于') + '岁')
    }
    // 基于准备好的dom，初始化echarts实例
    var myChart = echarts.init(that.$refs.main)
    // 指定图表的配置项和数据
    var option = {
      xAxis: {
        type: 'category',
        data: ageX
      },
      yAxis: {
        type: 'value'
      },
      series: [{
        data: ageY,
        type: 'bar',
        showBackground: true,
        backgroundStyle: {
          color: 'rgba(220, 220, 220, 0.8)'
        }
      }]
    }
    // 使用刚指定的配置项和数据显示图表
    myChart.setOption(option)
  }
}
```

## 个人设置模块

### 1. 基础布局

```html
<template>
  <div class='setting-container'>
    <el-card>
      <!-- 导航 -->
      <div slot="header">          
        <el-breadcrumb separator-class="el-icon-arrow-right">           
            <el-breadcrumb-item to="/">首页</el-breadcrumb-item>           
            <el-breadcrumb-item>个人设置</el-breadcrumb-item>         
          </el-breadcrumb>       
        </div>
      <!-- 栅格 -->
      <el-row>
        <el-col :span="12">
          <!-- 表单 -->
          <el-form label-width="120px">
            <el-form-item label="编号：">100</el-form-item>
            <el-form-item label="手机：">{{userInfo.mobile}}</el-form-item>
            <el-form-item label="媒体名称：">
              <el-input v-model="userInfo.name"></el-input>
            </el-form-item>
            <el-form-item label="媒体简介：">
              <el-input v-model="userInfo.intro" type="textarea" :rows="3"></el-input>
            </el-form-item>
            <el-form-item label="联系邮箱：">
              <el-input v-model="userInfo.email"></el-input>
            </el-form-item>
            <el-form-item>
              <el-button @click="updateUser" type="primary">保存设置</el-button>
            </el-form-item>
          </el-form>
        </el-col>
        <el-col :span="12">
          <!-- 上传组件 action必须属性-->
          <el-upload
            class="avatar-uploader"
            action=""
            :http-request="uploadPhoto"
            :show-file-list="false">
            <img v-if="userInfo.photo" :src="userInfo.photo" class="avatar">
            <i v-else class="el-icon-plus avatar-uploader-icon"></i>
          </el-upload>
          <p class="edit-photo">修改头像</p>
        </el-col>
      </el-row>
    </el-card>
  </div>
</template>

<script>
export default {
  name: 'my-setting',
  data () {
    return {
      // 用户信息
      userInfo: {
        name: 'test',
        intro: 'info',
        email: 'info@qq.com',
        mobile: '',
        id: '',
        photo:''
      },
      // 支持上传组件的数据
      imageUrl: null
    }
  },
  methods: {
  }
}
</script>

<style scoped lang='less'>
  .avatar{
    width: 178px;
    height: 178px;
    line-height: 178px;
  }
  .avatar-uploader {
      text-align: center;
  }
  .avatar-uploader-icon {
      font-size: 28px;
      color: #8c939d;
      width: 178px;
      height: 178px;
      line-height: 178px;
      text-align: center;
  }
  .avatar-uploader /deep/ .el-upload {
      border: 1px dashed #d9d9d9;
      border-radius: 6px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
  }
.edit-photo{
  font-size: 12px;
  text-align: center;
}
</style>

```

### 2. 展示初始账号信息

#### 2.1 准备接口方法

`src/api/user.js`

```js
/**
 * 获取用户的身份信息。
 * 这个接口是需要token信息才能访问的
 */
export const userGetProfile = () => {
  // 请求接口
  return ajax({
    method: 'GET',
    url: '/mp/v1_0/user/profile'
  })
}
```

#### 2.2 调用接口并初始化数据

```js
import { userGetProfile } from '@/api/user.js'
export default {
   methods: {
     loadUserInfo () {
      userGetProfile().then(res => {
          this.userInfo = result.data.data
      })
   },
   mounted(){
       this.loadUserInfo()
   }
}
```



### 3. 修改账号信息

#### 3.1 准备接口

`src\api\user.js`

```js
/**
 * 修改用户信息
 * @param {*} data
 * 直接传入一个对象：data: {name, email, info}
 */
export const modUserProfile = data => {
  return ajax({
    method: 'PATCH',
    url: '/mp/v1_0/user/profile',
    data
  })
}
```

#### 3.2 在事件处理函数中完成接口调用

```js
save () {
    // 解构赋值
    const { name, intro, email } = this.userInfo
    // 有一个：对象的简写格式
    modUserProfile({
      name,
      intro,
      email
    }).then(()=>{
       this.$message({
           type:'success',
           message:'保存成功'
       })
    })
}
```

### 4. 修改用户头像

#### 4.1 添加自定义请求行为

由于 element 的 upload 组件不支持自定义请求方法（默认是 POST，我们的接口要的是 PATCH），所以我们需要自定义上传组件的请求行为`http-request="uploadPhoto"`,它会覆盖默认的上传动作，可以自定义上传的实现

```html
<!-- 上传组件-->
<el-upload
	class="avatar-uploader"
	action=""
	:http-request="uploadPhoto"
	:show-file-list="false">
    <img v-if="userInfo.photo" :src="userInfo.photo" class="avatar">
    <i v-else class="el-icon-plus avatar-uploader-icon"></i>
</el-upload>
```

#### 4.2 准备上传接口

`src/api/user.js`

```js
/**
 * 修改头像
 * @param {*} formData  是一个FormData格式的对象
 */
export const moduserImage = (formData) => {
  return ajax({
    method: 'PATCH',
    url: '/mp/v1_0/user/photo',
    data: formData
  })
}
```

#### 4.3 uploadPhoto函数处理

```js
// 当用户选中文件时，会自动传入一个对象，用来表示当前要上传信息
 uploadPhoto (obj) {
     // 1. 取出要上传的文件
     const { file } = obj
     // 2. 调用接口
     const formData = new FormData()
     formData.append('photo', file)
     moduserImage(formData).then(res=>{
         this.$message.success('头像上传成功') 
         // 3. 更新
         this.userInfo.photo = result.data.data.photo
     }) 
 }
```

### 5. 将修改同步到头部

#### 5.1 理解eventBus模式（少量的组件之间需要进行数据传递)

模式说明：

1. Bus作为一个中间组件对象  用来接收消息和发送广播消息 （中介的位置）
2. 中间的componet组件用来发布消息  （传值的位置）
3. 俩侧的component组件用来接收消息 （接值的位置）

<img src="assets/eventBus.png" style="zoom:50%;" />

#### 5.2 全局添加eventBus对象（Bus）

`main.js`

```js
Vue.prototype.eventBus = new Vue()
```

#### 5.3 Layout组件监听事件 （俩侧组件）

```js
// 监听事件
this.eventBus.$on('setUserName', (name) => {
  this.user.name = name
})
this.eventBus.$on('setUserPhoto', (url) => {
  this.user.photo = url
})
```

#### 5.3 设置组件触发事件 （中间组件）

```diff
uploadPhoto (obj) {
  // 1. 取出要上传的文件
  const { file } = obj
  // 2. 调用接口
  const formData = new FormData()
  formData.append('photo', file)
  moduserImage(formData).then(res => {
    this.$message.success('头像上传成功')
    // 3. 更新
    this.userInfo.photo = res.data.data.photo
+   this.eventBus.$emit('setUserPhoto', this.userInfo.photo)
  })
},
save () {
  // 解构赋值
  const { name, intro, email } = this.userInfo
  modUserProfile({
    name,
    intro,
    email
  }).then(() => {
    this.$message({
      type: 'success',
      message: '保存成功'
    })
+   this.eventBus.$emit('setUserName', this.userInfo.name)
  })
```

## 项目打包

实际的上线流程

> 前端要做的是把代码提交到远程仓库  然后把分支名字告诉测试  测试同学会拿着分支名字进行代码发布
>
> 自动化发布工具：jekins  （等类似的自动发布平台）
>
> 1. 拿到要发布的分支名称
> 2. 根据分支名称找到对应的代码
> 3. 将代码发到对应的服务器上（测试环境1 /测试环境2 /  预发布环境1 / 正式环境）

### 1. 常规打包（打包的时候把浏览器预览关掉）

```bash
npm run build
# 会自动生成dist文件夹里面存放了打包之后的文件资源
# 打包的过程会进行必要的代码压缩
```

### 2. 配置打包主路径

`vue.config.js`

```js
module.exports = {
  lintOnSave: false,
  publicPath: process.env.NODE_ENV === 'production'
  ? ''
  : '/'
}
```

### 3. 打包都做了什么

1. 生成一个新的dist文件目录 里面自动生成项目的所有静态资源

   ```
   每次执行npm run build 都会先删除dist文件夹 然后重新创建一个新的dist
   ```

2. 对于js资源和css资源都会进行压缩丑化处理 减小资源体积

   ```
   前端对于静态资源的体积非常敏感
   ```

3. 自动根据文件内容生成当前的版本号 利用版本号进行浏览器的缓存清理保证用户能看到的是最新的代码

   ```
   浏览器对于静态资源文件有缓存机制  第一次加载完毕之后会进行本地缓存 第二次再次加载速度会变很快,如果资源的名称不变 浏览器会默认使用缓存的资源  用户不能第一时间看到最新的代码
   ```

4. 将公共的资源(chunk-venders)单独打包出来 进行长期的缓存 提高应用的加载速度

   ```
   vue.js/element.js/element.css  这些文件是大概率不会发生变化的所以我们单独进行打包 达到一个长期缓存的目的
   ```

5. 图片资源处理 

   ```
   大于10KB的会自动存入img文件夹  小于10Kb的会进行base64转换 直接放到css中进行加载
   ```

6. 自动将页面需要的静态资源添加到index.html中对应的位置上去

   ```
   css自动加到<head>标签中  js资源自动加到<body>标签结束之前
   ```


### 4. 配置按需加载

##### 问题

由于单页应用的特点导致首次加载的静态文件太大，会导致首次渲染时间太长，影响用户体验

##### 解决方案

将路由绑定的组件按需加载  切换到当前路由时才加载组件用到的资源文件（js，css）

##### 具体配置

```js
// 样例参考
const routes = [
  // 不具备按需加载
  {
    path: '/',
    name: 'Home',
    component: Home
  },
  // 按需加载的配置
  {
    path: '/about',
    name: 'About',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () => import(/* webpackChunkName: "about" */ '../views/About.vue')
  }
]

// 项目改写
const routes = [
  {
    path:'/',
    name:'Layout',
    component: Layout,
    redirect: { name: 'Home' },
    children:[
      { 
        path:'home', 
        component: () => import(/* webpackChunkName: "home" */ '@/views/Home'),
        name:'Home'
      },
      { 
        path:'articles', 
        component: () => import(/* webpackChunkName: "article" */ '@/views/Article'),
        name:'Articles'
      }
    ]
  }
]
```

### 5. 发布到gitee

1.提交dist打包目录

`.gitignore`

```
dist/  删除 容许提交到仓库
```

2.在gitee中开启静态服务

```
服务 -> gitee pages -> master分支 -> /dist/目录
```

注：如果修改了代码之后需要重新执行npm run build命令 进行重新打包   然后再提交到远程仓库  再执行一遍更新服务  

![](http://cp_fe.gitee.io/assets/vue/gitee.png)

## 问题扩展

### 1. 深度作用选择器

背景：

css原生是不支持模块化 和作用域的  所有的样式都是基于全局的 加上我们现在组件化的开发模式，有很多的组件嵌套  如果css类名重复就会出现样式互相影响的问题，为了解决这个样式覆盖的问题 引入了css scoped机制

具体做法：

在每一个.vue中的style标签上添加一个 属性 scoped  

作用：

当前style中的样式只针对当前.vue文件组件内容生效  不会影响其子组件

例子：

`app.vue`

```js
<style lang="less">
  .container{
    font-size:100px;
    color:red;
  }
</style>
```

`login.vue`

```html
<div>
  <div class="container">我是测试文字</div>
</div>
```

此时login组件中的文字会受到父组件的影响  显示100px大小  颜色为红色

解决方案:

`app.vue`

```html
<style lang="less" scoped>
  .container{
    font-size:100px;
    color:red;
  }
</style>
```

修改之后 子组件中的类名为container元素中的文字将不会受到影响

**注意事项：**

如果子组件中的根元素和父组件中的类名发生了匹配，同样会受到影响，除了根元素之外，其它内部元素都不会受到影响

https://vue-loader.vuejs.org/zh/guide/scoped-css.html

如果你希望 `scoped` 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 `>>>` 操作符：

```html
<style scoped>
.a >>> .b { /* ... */ }
</style>
```

上述代码将会编译成：

```css
.a[data-v-f3f3eg9] .b { /* ... */ }
```

有些像 Sass 之类的预处理器无法正确解析 `>>>`这种情况下你可以使用 `/deep/` 或 `::v-deep` 操作符取而代之——两者都是 `>>>` 的别名，同样可以正常工作



### 2. JSON.stringify  JSON.parse

```js
// json字符串 ->  json对象
// json是一种非常严格的数据格式
// 容错很必要
try {
   return JSON.parse(jsonstr) 
}catch(error){
   return {}
}

// 数据很规范化一般后端返回的接口数据的深拷贝
let obj = {
    name:'cp',
    age:20
}
let copyOjb = JSON.parse(JSON.stringify(obj))
```

### 3. async/await 改写 promise

> async/await 提供了看起来像是同步代码的异步处理手段，只是语法糖
>
> promise功能上更加强大  async/await更符合同步语义

**改写promise案例**

`src/views/Layout`

```js
// 原始promise
hGetUserInfo(){
  getUserInfo().then(res=>{
    // 如何页面数据和后端接口数据一一对应整体覆盖保持字段对应即可 
    // 如果页面数据大量少于接口数据  解构然后赋值
    this.userInfo = res.data.data
  })
}
// 改写之后看起来更像是同步代码
async hGetUserInfo(){
  try{
     const res = await getUserInfo()
     this.userInfo = res  
  }catch(err){
     console.log(err)
  }
}
```



