[TOC]

## 自我介绍

面试官您好，我叫张鹏飞，今年22，我个人爱好是跑步,我来自山西，大学所学的是计算机网络技术专业，平时通过MDN，掘金，CSDN，等博客获取新知识，我在上家公司任职的是web前端开发，在职期间我负责了三个项目，第一个接手的是用jq做的官网，它有两套页面，一个是PC的一个是移动端的，一个是关于电商公司的后台管理系统使用的是vue技术栈，最后一个项目也是用vue写的关于科技网站的移动端的项目， 嗯，我介绍完了。

## 专业技能

### 闭包

+ 什么是闭包

  在函数中去访问其它函数中的变量就会形成闭包。

+ 闭包的好处和坏处

  好处：可一直存储在内存中，不会被垃圾回收机制回收。

  坏处：正因为一直存储在内存中，内存一直不会被释放，占用会很大，所以不能滥用闭包，在使用	完这个变量后退出函数前将其删除清空

+ 你的项目中用到闭包了吗

  用到了，我在项目中用到最经典的场景就是封装防抖函数时用到的，闭包起到的作用就是在作用域内保存定时器的id，便于清除上一次的定时器，还有一个是用原生js给tab栏循环绑定事件，for循环后，获取到当前 循环项的id然后绑定事件执行一个封装好的回调函数，参数为当前循环项的内容。

### vue动态添加路由

首先在router.js中声明一个公共路由表比如 login，登录成功后后端返回路由权限，根据权限得到需要动态添加(前端处理)，或者是后端直接返回路由表（后端处理），通过__router.addRoutes()__ 动态添加到 router中即可。

### 双向绑定原理

> 通过数据劫持结合发布者,订阅者模式的方式来实的,通过 Object.definePropertyget劫持各个属性的getter和setter方法，get是获取属性时调用，set属性变化时调用，从而可以在里面做一些更新视图的操作，但是订阅者(watcher)是有多个的，怎么能知道那些订阅者需要更新，这时候就需要使用一个dep来收集订阅者(watcher)，进行统一管理，此外还需要一个指令解析器，对每个节点元素进行扫描和解析指令，再将对应的指令初始化并绑定相应更新(update)函数，此时订阅者接收到相应属性的变化，就会执行对应的更新函数，实现更新视图。

```js
执行的步骤大概是这样的：

1.vue实例在初始化时会拿到当前data中的数据，调用一个 initData(vm) 方法初始化数据。 
2.在 initData 方法中调用 Observer(val) 方法并传入数据，判断如果数据没有被观测过的话就是用 new Observer(value) 观测数据,观测的一种是数组，一种是对象。
3.如果是对象型非数组的话调用 this.walk(value) 方法，会把当前传入的对象进行循环调用Object.defineProperty。
4.使用 Object.defineProperty 重新定义数据,在判断如果当前对象的至还是一个对象的话，回到第2步进行递归。
5.取值时调用 Object.defineProperty 的 get() 方法收集（订阅者）watcher。
6.如果数据改变时调用set()，通知（订阅者）watcher去更新数据,如果当前值和数据的值不一样的话调用 dep.notify() 通知视图更新。

	
** 基础类型的数据是不会进行观测，只监测data对象
```

### vue2中怎么响应式数组的

> Object.defineProperty是监听不到数组的变化的，而是使用函数劫持，对数组常用的7个原生可改变数组的方法进行了改写，只要数组一改变就通知观测者

```js
vue将data中的数组，进行了原型链重写，指向了自己定义的数组原型方法，这样当调用数组API时，可以通知依赖更新，如果数组内包含引用类型，会对数组中的引用类型再次进行监控。

1.vue初始化时会拿到当前data中的数据，调用 initData(vm) 方法初始化数据。 
2.在initData中调用 Observer(val) 方法，判断如果数据没有被观测过的话就是用 new Observer(value) 观测数据,再判断如果有__ob__且类型是observer的话说明已经被监听了直接返回数据，观测的一种是数组，一种是对象。
3.如果为数组，让就让它的原型链指向 arrayMethods ，来改写数组方法。
4.只要调用了数组方法，就会执行一个函数，执行原来的方法并通知视图更新，ob.dep.notify()
5.如果使用了数组新增方法,push,unshift,splice的话，调用ob.observeArray(新增的数据)遍历数组的每个对象进行深度观测，所以只有数组里的对象才能进行响应式的数据变化。
```

### key的原理

> 首先它的作用是：更高效的更新虚拟dom，提高diff算法的速度。
>
> 在vue中，我们是不需要直接操作dom的，只需要操作数据就可完成页面的渲染,vue通过虚拟dom去操作真实dom实现渲染，在渲染时使用的是diff算法，使用v-for更新渲染过的元素列表时会采用就地复用策略，简单复用此处每个元素。

+ 默认的diff算法,也就是不加key的话，默认执行是这样的，比如说有abcd4个节点，我们要在b和c之间插入一个e节点，那么当e插进去后，旧节点c的状态就会被e复用，d被c复用,这样新d永远都会在最后一个节点，会造成状态混乱。

+ 加上key之后，相当于给每个节点加上一个唯一的标识，diff算法就可以正确的识别此节点，找到正确的位置插入新节点，并复用自身的状态，从而重用和重新排序已有节点。

+ **diff算法**：通过对比同一层的新旧虚拟dom,将有变化更新的地方渲染在真实dom。

+ **虚拟dom**：用js对象的形式模拟一个真实dom，如果直接操作dom的话，每次更新dom 都会造成重绘和回流，而使用虚拟dom 对比节点时放在js来做，可以避免真实dom 重复大量渲染。

  **其实，虚拟dom的子元素列表只包含文本节点且dom结构一致，不设置key效率会更高，因为不会涉及到过多的判读逻辑**
  
  **不推荐使用下标作为key,因为会导致内存性能的浪费，比如有一个列表，删除列表的第一项时，其下标也会改变，导致diff无法关联起上一次一样的数据，所以用下标作为key是不稳定的。**

### vue通信

分为父子通信和非父子通信

+ **父子通信**
  1. props + $emit
  2. provide + inject (可以进行子孙传参)
  3. $parent (获取当前组件的父组件实例)+ $children(获取子组件，是一个数组)
  4. ref (不推荐使用，因为它会直接操作dom)
+ **非父子通信**
  1. eventBus
  2. vuex

### 轮播图的原理

大体的原理就是，利用浮动将所有所有照片依次排成一行，给这一长串图片添加一个父级的遮罩，每次只显示一张图，其余的都隐藏起来。对图片添加绝对定位，通过控制left属性，实现照片的移动，每次触发动画时，通过全局变量标记，获取当前页数，操作清除所有小圆点，然后指定一页添加样式

### vue项目中怎么做移动端适配

postcss-pxtorem 包和 amfe-flexible，postcss-pxtorem将px转为rem,使用amfe-flexible实现rem自适应。

### 节流

在一段时间内只执行一次函数或者事件，实现降频。

```js
function jl(fun,ss){
    let time = null;
    return function(){
        let thas = this
        let arg = arguments
        if(!time){
            time = setTimeout(()=>{
                fun.apply(thas,arg)
                time = null
            },ss)
        }
    }
}

function fun(){
    console.log('节流了')
}

documetn.getElementById('id').addEventListnere('click',jl(fun,1000))
```

### 防抖

```js
function fd(fun,ss){
    let time = null;
    return function(){
        if(!time) clearTimeout(time)
        time = setTimeout(fun,ss)
    }
}

function fun(){
    console.log('防抖')
}

document.getElementById('id').addEventListener('click',fd(fun,1000))
```

### get  和 post 区别 

+ get 主要获取服务器的资源数据，通过url传参		
+ post 主要是向指定的资源提交要被处理的数据
+ 区别：

1. 安全性：get参数url可见，post url不可见，原则上post比get安全，毕竟传参url不可见，但是抓包会抓到，防君子不防小人。

2. 数据传输：get是通过拼接url进行传参，post 通过body体传输

3. 缓存性：get请求是可缓存的，post不可缓存

4. 后退页面：get后退时，不产生影响，post后重新提交

5. 传输大小：get传输数据不超过2k-4k，浏览器不同限制不同

   ​		    post传输数据大小取决于服务器的设置和内存，所以可无限制。

### 你的vue项目怎么处理兼容的

因为在项目中我使用 axios ,然后当在ie中打开时报错 promise 未定义，我查了一下资料因为ie使用的是 trident 内核，这个内核不仅支持 promise，而且还不支持箭头函数（可安装插件或者改为function解决），我是通过下载 babel-polyfill 包解决 ie不兼容 promise 的，关于ie的其它的兼容性问题我没有过多的深究。

### 你做过那些优化

>  从网络优化，代码优化，用户体验优化,打包优化

+ **网络优化**

  1. 浏览器并发

     因为 ip 是基于 tcp 协议的，限制浏览器只能在同一时间内发送6-7个请求，如果网不好的话，超过请求就会阻塞。

     **解决**:使用雪碧图和图片懒加载技术，对于某些静态资源，可将其合并到同一个http请求。

  2. 防抖和节流，实现对请求的降频。

+ **代码优化**

  1. 一些不影响页面的功能代码使用 async(没有顺序) defer(有顺序) 异步加载。
  2. 减少直接对dom的操作，避免重绘和回流。
  3. css样式必须加 scoped 防止样式干扰。
  4. v-if 和 v-show 的使用场景，v-if性能消耗更多，所以需要频繁切换时使用v-show。
  5. 路由使用 import  动态加载。
  6. 第三方组件使用按需加载。

+ **用户体验优化**

  1. 页面加载时或用户点击按钮时触发 loading 提示。


​	还有一些就是项目中的一些bug优化。

### 项目中遇到的难点

1. 频道管理

   > 那我就说一下我最后做的这个移动端的，是主页的频道管理这一块,有这么几个共功能，就是点击频道管理时，它会弹出一个底部弹层，弹层中的内容的上面是我的频道，下面是可选频道，我的频道因为之前在父组件中已经调用接口获取到了，所以这里直接以props以数组的形式接收，渲染到视图就可以了，可选频道是通过调用所有频道接口减去用户频道实现的，但是怎么去计算，在哪里计算？我一开始是没有考虑将它到用计算属性计算的，后来做到删除用户频道那一块的时候发现在子组件中删除时还要去实时的改变父组件的频道列表让它的数据和子组件的频道同步，所以我想到了可不可以利用计算属性的特性然后子组件修改父组件传过来的值触发父组件中的计算属性，我查了一些资料，如果父组件传的是一个引用型数据类型的话，那么子组件是可以修改父组件中的数据的，如果是普通数据类型在子组件中是不可以修改 props 的值的，然后我就看了一下它的源码，发现vue在初始化 props 时会调用 definedRactive 方法，这个方法就是来运行object.definedProperty 对传入的object绑定get和set的，而它传入的第四个参数就是来触发set的回调，判断是否是子组件修改的props，所以，当修改props时vue会发出警告，提示你不可以修改这个值，官网解释说是 props是一个单向下行绑定的，就是父级 prop 的更新会向下流动到组件，返过来不行，但是有一点，在源码中这里只能监听普通型数据类型，我想作者的意图是防止一些新开发者的错误操作。
   >
   > 然后回到之前的思路，当点击删除时，传入当前下标，获取当前下标元素的id，调用接口删除频道，并且使用splice方法删除用户频道数组中的当前项，由于修改了父组件传过来的用户频道数组，父组件也会改变，数据一改变就会触发计算属性，重新计算进行可选频道，并且父子之间的值还是同步的，添加的时候也是这个逻辑，让计算属性重新计算。

   还有token的过期处理。

   文章详情页组件的三层嵌套。

### http常见的状态码

+ **200**：客户端请求成功，并成功处理。
+ **204**：客户端请求成功，但是没有资源返回。
+ **206**：表示部分请求请求成功(一般实在客户端表明自己只需要目标URL上的部分资源的时候返回的)
+ **301**：永久重定向，表示请求资源被分配了新的url，之后使用应该使用更改的url。
+ **302**：临时重定向，请求的资源被分配了新的url，希望本次访问使用新的url。
+ **303**：临时重定向，和302一样，但是应该使用get方法定向获取请求的资源。
+ **307**：临时重定向，与303一样，307会遵照浏览器标准不会从post变成get（视浏览器而定）
+ **400**：表示请求报文中存在语法错误。
+ **401**：未经许可，需要通过HTTP请求（token过期）。
+ **403**：服务器拒绝本次访问(访问权限出现问题)。
+ **404**：表示服务器无法找到请求资源，也可以在服务器拒绝请求但不想给拒绝原因时使用。
+ **500**：服务器遇到未知的错误，导致无法完成客户端当前的请求。
+ **503**：服务器过载或是维护，无法解决当前请求。



### 深拷贝 

```js
    function sCopy(obj){
        // 1. 初始化一个新对象
        let _NEWOBJ = obj
        // 2. 判断原型链是否为object
        if(typeof obj == 'object'){
            // 3. 判断是数组还是对象
            _NEWOBJ = Array.isArray(obj)?[]:{}
            // 4. 遍历
            for(i in obj){
                //5. 对它的数据进行递归拷贝
                _NEWOBJ[i] = sCopy(obj[i])
            }
        }
        // 6. 最后return出去
        return _NEWOBJ
    } 
```

### vue的销毁生命周期中可以做什么操作

断开websoke.io的连接，销毁定时器


## 工作经历

+ **你今天刚毕业，为什么有2年经验**

  因为这个公司一开始是我们学校的一个学长推荐给我的，所以我在去年3月份的时候是以实习生的身份在该公司工作的，到大三该实习的时候，我就转正了。

+ **为什么离职**

  有两个原因：一方面是因为地区的原因，因为上家公司的发展空间达不到我的期望，我想在提升自己的能力，趁着我年轻来北京试试，对自己的技术提升也有帮助。第二个方面是因为，我家里人也在这边工作嘛，平时能见得着面。

+ **你们的团队怎么分配的**

  1个技术总监：负责选择所用技术

  1个产品经理：负责产品的选择，周期。

  3个技术组：每组1个前端3个后端（java）。

  1个测试

  1个ui

## 项目经验

### 电商企业人员后台管理系统

> 这个项目是给一个电商公司做的管理系统，我负责的是员工与部门管理，角色权限管理，任务管理，系统设置，模块。
>
> 此外还负责了首页和登录功能的编写。
>
> 客户模块是另一个前端开发的

+ **登录模块**

  首先它整体布局使用element-ui的表单做的，用户输入用户名和密码后，会先校验是否通过，通过后，才可调用接口，服务器返回token时，会将toke存在本地存储localhost中，其次为了防止用户的非法访问，使用路由的 beforEach() ,实现了全局的导航守卫，通过判断路径和token是否存在实现 的。
  
+ **首页模块**

  主要使用 echarts 做了数据的可视化，用柱状图展示了员工的年龄段的统计。用饼状图做了各个部门的员工占比。
  
  还有最新发布的任务。

+ **员工与部门模块**

  __部门功能：新增，编辑，删除。__

  1. 右侧是一个二级下拉菜单，比如说1级是销售部，2级是销售部下小组，销售1，销售2。

  1. 点新增会弹出一个element-ui的弹出层，需要输入小组名称 和 部门名称，这里有一个二级联动，使用了change事件，当选中部门之后才会根据所选的部门名称去调小组接口。

  2. 点编辑时会获取当前部门信息和id，将信息回显到弹出层，提交时将部门id作为参数和修改好的信息一起提交。

  3. 点删除时获取id，调用接口删除，同时通过下标删除数组中的数据。

  __员工功能：添加，删除，修改，查询。__

  1. 点击添加的时候也会弹出 element-ui 的弹出层，添加员工的字段有手机号（登录名），登录密码，姓名，性别，年龄，邮箱，部门，岗位，上级，角色，岗位（外派还是在公司）提交时做表单验证成功后才会收集所填写的字段信息并调用接口。
  2. 点删除之后根据id删除，一旦删除数据不可恢复，需要重新添加。
  3. 和添加的字段一样 ，点修改时首先会将当前点的员工信息收集起来，并在element-ui弹出层中做一个信息数据的回显，然后确认修改，手机表单信息调用接口。
  4. 可输入员工姓名查询。

+ **角色权限管理**

  每个账号都拥有角色，每个角色代表了它在系统中有的权限。

  角色的权限有两部分：操作权限 和 数据权限，一个账号可有多个角色，最多3个角色。

  + 默认角色

    **A类**：超级管理类

    超级管理员角色，不可被删除，默认有所有角色的权限，只能有1个。

    **B类**：模块管理类

    员工部门管理角色：可以对员工和部门进行编辑，删除，添加操作。

    公告管理角色：对系统公告进行维护。

    自定义其它角色：设置其对指定模块操作的权限。

    **C类**：下级管理类

    xx部部长角色：可以修改和添加该部门员工的信息，设置和添加下级小组，小组长。

    部门组长角色：可以修改当前组员信息。

  ​	    **D类**：无任何权限

  ​		员工角色：只能操作自己的办公工作区域。

  + 功能

    可对自定义其他角色授权，点击角色授权 可显示操作权限（可以使用那些功能） 和 数据权限（可以看那些数据，比如查看某个模块的权限和操作某个模块的权限）。

+ **任务管理**

  功能：新建任务，任务详情，

  新建任务：字段有：任务名称，创建人，参与人，开始时间，结束时间，优先级（高中低），任务描述

  任务列表：使用 element-ui 的表格渲染到页面的。

  任务详情：在任务列表中点任务弹出回显框，可通过id查询到当前的任务详情，创建人可修改任务我描述和优先级，参与人。

  **任务评论**：任务参与人可以对任务进行评论报告进度和回复。

+ **系统设置**

  主要包含：系统登录页面的名称和logo的配置。

  


### 指道科技

> 指道科技是一个it网站，主要模块有登录，首页，视屏，我的三大模块。

+ **登录**

  使用 vant 的表单组件布局页面，用:rules校验，成功后调用submit函数,调用接口发起请求。

  成功后使用 this.$store.commit 将 token 存入 vuex 中，并在 mutations 中定义一个函数将 token 存入本地做持久化,gettes vuex 中的计算属性。

+ **首页模块**

  导航栏右侧搜索功能：点击搜索，跳转到搜索中心

  **频道列表**：在data中提前定义好频道列表，调用频道列表接口将数据赋给频道列表，在视图中通过 v-for 渲染到 vant 标签页组件。

  **文章列表**：vant 下拉刷新组件结合列表。实现下拉时刷新文章列表数据，上拉时加载更多。

  **频道管理**：抽离为组件，在父级使用 vant-action-sheet 弹层包裹，判断Vuex中的store.gettes.token如果有则显示频道管理按钮, 有用户频道和可选频道，**可选频道 = 所有频道 - 用户频道**，先调用所有频道接口，然后在计算属性中计算，创建一个函数，使用filter循环所有频道，然后在里面使用 findIndex 循环用户频道，对比频道的id,如果用户没有那么return出去，最终计算出一个可选频道。

  点击编辑的时候，用户频道出现x号，且编辑变为取消。

  点击某一条文章通过父子传值，跳转到详情页，父组件定义一个自定义属性，子组件使用props接受这个id，然后在钩子函数中将id作为参数去 调用文章详情接口。

  + **搜索中心页面**

    页面结构可以分成三部分，输入区 search 组件，提示区 cell 组件，历史记录区。

    功能：在用户搜索时智能提示，保存用户的搜索记录。

    1. 监听搜索框(@input)输入的内容，内容变化时将最新的输入内容作为参数调用接口渲染到提示区域。
    2. 渲染时使用 vue的过滤器配合正则 *new RegExp* 做一个智能提示文字的高亮效果。
    3. 点击提示的关键词，将其存入历史记录中，且跳转页面。
    4. 判断当前如果正在输入将 历史记录隐藏。
    5. 点x删除对应下标的历史记录。
    6. 使用防抖节流优化。

  + **文章详情**

    功能：渲染页面，（关注，文章点赞，喜欢，评论点赞），发布评论，回复评论。

    评论页面：抽离为子组件，封装接口，注册处理函数，根据父组件传过来的 id 渲染评论列表。

    评论回复：抽离为组件，用户点击某条评论的回复按钮时，从底部 弹出 popup组件 ，这个子组件的布局里包含：当前评论的内容。已有回复，添加回复的input框，输入回复内容确认后调用接口。

    __文章详情页 --》评论页 --》回复评论页 __ 实现三层组件嵌套。

    + **问题**

      1. 每次点击回复时，都去创建一个新 commentReply 组件,从而导致只会发起第一次请求。

         解决：补充一个 v-if 来控制动态创建组件。`v-if="isReplyShow"`。

+ **视屏模块**

  这一块的思路和文章详情的思路是一样的，只是渲染页面时渲染的是一个后端给的gif图片，然后点的时候通过父子传id的方式跳转到详情页面，跳转过去后，才会正式自动播放视屏。

+ **我的模块**

  使用 v-if 判断 token 如果有则显示用户的信息，如果没有则显示未登录，点击未登录跳转到登录页面。
  
  加载页面时调用接口回显到页面，判断路由路径， 隐藏顶部导航栏，布局结构，用的九宫格。
  
  功能：退出登录，编辑资料，小智同学。
  
  退出登录：回到登陆页面，清空本地信息，在 vuex 中添加mutations，点击退出，使用映射调用 vuex gettes中的函数，做清空token操作。
  
  编辑资料：内容较多，抽离为组件也是一个新的路由，获取本地的用户信息回显到页面，要注意的点是修改头像时后端要的formData格式，使用一个隐藏的file类型的input 实现的 点击头像时，执行隐藏的 file 点击事件。
  
  小智同学：使用 webscoket （XMLHttpRequest 对象）实现的，使用 **socket.io** 框架,监听 connect事件：连接成功，message事件：收到回复。点击发送封装消息通过emit发送，最后 使用 scrollTop = scrollHeight 使滚动条回到最底下。
  
+ **权限处理**

  使用全局导航守卫，访问需要token的页面时，如果没有跳转到登录页。

+ **遇到的难点：**

  + **token过期处理**

    登录成功后后端会返回两个 token 一个2h的有效期，一个14天的有效期，当 token 过期在发请求就是报 401错误。当2h的token过期后，调用14天的token重新获取一个2h的 token。

    使用 axios 的响应拦截器实现，判读如果某次请求是401，有14h的token用它去请求新的2h的token,成功更新本地token,在发一次报401错的请求，失败则携带请求地址，跳到登陆页面。

  + **怎么计算频道管理的可选频道**

+ **优化**

1. 文章详情回退到主页时，会重新加载主页的数据和请求。

   原因是因为路由跳转时，组件会被销毁重建。

   解决：通过 keep-alive 组件 来对主页组件按需缓存，给路由标记一个原信息 mate { isKeepAlive:true }

2. 文章列表没有一个记录点，点击一个文章进入详情页，然后点返回，滚动条就会回到最顶上。

   解决：使用 scrol 监听事件实时记录位滚动条置，并做一个防抖处理，当keep-alive组件激活时（activated 钩子函数）恢复滚动条位置。


+ **bug**

  1. 文章详情返回死循环

     在用户没有登录的情况下访问文章详情页然后，点击左上角返回会返回到登录页，登陆后回到文章详情，在点击返回，又回到登录页，造成死循环。

     解决：用局部组件导航守卫（beforeRouteLeave），判断 如果去的是login页面的话，判断是否有token有则跳到主页。




