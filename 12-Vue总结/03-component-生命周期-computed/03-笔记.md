# 03-vue

## computed计算属性

> 当其依赖的属性值发生变化时，计算属性会重新计算，反之则使用缓存中的属性值

###为什么需要computed

当模板中的表达式放入太多逻辑时，会让模板变重，难于维护，所以需要computed来解决逻辑。

###特性

1. 虽然定义的是一个函数,但是它叫做计算属性所以使用时不加()

2. computed属性中依赖的属性只要发生改变，就会重新计算

3. computed属性是响应式的，计算属性重新计算后，会渲染到视图模板

4. computed属性是有 缓存特性的只有第一次使用会调用函数，以后在遇到会使用缓存

5. computed属性不适合做大开销操作，经常和模板进行配合使用

   watch灵活，可以做大开销操作，一般不和模板配合

###语法

```js
<div>{{c}}</div>
{
    computed:{
        c(){ 
            return this.a +this.b
        }
    }
}
```


## watch监听器

> 监听实例化属性的变化，一旦属性发生变化之后立即执行绑定的回调函数，经常用来做ajax调用接口

+ 不要滥用用watch，多用computed

###语法

```js
{
    watch:{
        '要监听的数据名':function(){ //这里不支持箭头函数
        }
    }   
}
```



## vue的生命周期

>  vue实例从**创建、初始化数据、挂载、更新、销毁**，这就是一个组件所谓的生命周期。 每一个期间都有一个生命周期钩子函数



###vue的执行阶段

```js
1.new Vue()实例化vue对象
2.初始化事件和生命周期
3.执行beforeCreate() //vue实例化内的东西都没有之创建前
4.挂载数据，属性和computed的运算
5.Created() //此时vue对象的属性有值了，但是dom视图模板还没有生成
6.检查el，检查是否有template属性,无则等手动绑定vm.$mount
7.beforeMount() //数据挂载到视图模板之前
8.dom视图模板编译，用vue中的数据替换模板中的内容
9.mounted() //视图模板编译完成，数据挂载完毕


10.beforeUpdate() //模板中绑定的数据更新后，才能触发,数据不出现在模板里，就没必要再次渲染
11.updated() //vue（组件）对象对应的dom中的内部（innerHTML）改变了
12.activated() //keep-alive组件激活时调用
13.deactivated() //keep-alive组件停用时调用
14.beforeDestroy() //vue（组件）对象销毁之前
16.destroyed() //vue组件销毁后
```

### vue的生命周期钩子函数

```js
生命周期函数：
1.beforeCreate(), 这个函数执行的时候数据还没有被初始化
2.created（），执行时数据被初始化
3.beforeMount()，表示模板已经编译完成，但尚未渲染到页面中
4.mounted(),内存中的模板，已经被真实的挂载带了页面中

//运行中的两个事件
5.beforeUpdate(){} 这时候，界面没有更新，数据更新了
6.updated(){} 事件执行时数据和页面已经保持同步了
```





##vue component

> 每一个独立的功能区域都可以构成一个组件，一个完整的页面往往是有多个组件搭建出来的，组件的优点是复用性

+ data为什么是函数？

  因为只有声明为函数，才能渲染一次调用一次函数，且不会影响不同实例化中的数据。

### 全局component

```js
<name-component></name-component>

Vue.component('name-component',{
    //组件所有配置
    template:` 
		要渲染的html
	`,
    data(){ //data是一个函数，在函数返回中定义响应式数据
        return:{
            属性
        }
    },
    methods:{
        方法
    }
}
})
```

###局部component

```js
const Module = {	//vue会识别驼峰，并自动转为-
    data(){
        return {
            属性
        }
    },
    template:`html`,
    ..
}

const vm = new Vue({
    el:"",
    data:{},
    components:{
        Module
    }
})
```

### component的嵌套

1. 要避免循环嵌套
2. 组件嵌套不限制组件类型，全局和局部之间可以互相嵌套
3. template中只能有一个根元素

+ 全局的嵌套

  ```js
  <component-name><component-name>
      
  Vue.component('component-name',{
  	template:`
  	<component-name2></component-name2>
  	`
  })
  
  
  Vue.component('component-name2',{
  		    
  }) 
  
  
  --默认状态下组件内部的内容会被忽略，比如组件嵌套，组件2不会生效
  <componente1>
      <componente2></component2>
  </component1>
  ```

  

+ 全局内嵌套局部

+ 局部内嵌套全局
+ 局部内嵌套局部



## vueCallAPI案例





## 工具

### mock数据

+ 为了提高前端开发速度，降低对后端的依赖，自己造数据

### json-server包

```js
1.下载json-server
npm install json-server -g


2.启动一个json服务器文件
json-server --port 端口 json文件
```



## ？

1. 计算属性可以传参吗？

   不能

2. computed属性和watch的区别

   computed：适合多个数据或对象进行计算处理后返回一个结果，

   watch监听一个data中属性的改变。

3. computed属性和methods的区别

   ```js
   1.computed有缓存，methods没有缓存，
   2.computed是响应式的，methods并非响应式。
   3.computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。 
   ```

   

